<!DOCTYPE html><html lang="zh_CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java | 早起星人</title><meta name="author" content="早起星人"><meta name="copyright" content="早起星人"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java知识点总结">
<meta property="og:type" content="article">
<meta property="og:title" content="Java">
<meta property="og:url" content="http://example.com/2023/06/19/Java/index.html">
<meta property="og:site_name" content="早起星人">
<meta property="og:description" content="Java知识点总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png">
<meta property="article:published_time" content="2023-06-18T16:00:00.000Z">
<meta property="article:modified_time" content="2023-06-19T03:35:07.409Z">
<meta property="article:author" content="早起星人">
<meta property="article:tag" content="后端开发面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png"><link rel="shortcut icon" href="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/%E7%BD%91%E7%AB%99%E5%9B%BE%E6%A0%87.png"><link rel="canonical" href="http://example.com/2023/06/19/Java/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-19 11:35:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230511141236.png" onerror="onerror=null;src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/top_image/picture/java-top.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="早起星人"><span class="site-name">早起星人</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-06-18T16:00:00.000Z" title="Created 2023-06-19 00:00:00">2023-06-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-06-19T03:35:07.409Z" title="Updated 2023-06-19 11:35:07">2023-06-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ul>
<li><h3 id="hashmap的结构及原理jdk1.8以前和以后">Hashmap的结构及原理(JDK1.8以前和以后)</h3></li>
</ul>
<blockquote>
<p>HashMap是Java中常用的数据结构，用于存储键值对。在JDK
1.8之前和之后，HashMap的结构和原理有一些差异。</p>
<p><strong>JDK 1.8之前的HashMap结构及原理：</strong></p>
<p>在JDK
1.8之前，HashMap使用数组和链表的结合来实现。它的内部结构主要包含以下几个重要的部分：</p>
<ol type="1">
<li><p>数组（table）：HashMap的底层是一个数组，用于存储元素。数组的每个元素称为一个桶（bucket），每个桶可以存储一个或多个键值对。</p></li>
<li><p>链表（LinkedList）：当多个键值对被映射到同一个桶时，它们会以链表的形式存储在桶中。每个链表节点包含一个键值对。</p></li>
<li><p>哈希函数（Hash
Function）：HashMap使用哈希函数将键映射到对应的桶位置。哈希函数的目标是尽可能均匀地分布键值对，以提高性能。</p></li>
<li><p>扩容（Resizing）：当HashMap中的元素数量超过阈值（负载因子），HashMap会进行扩容操作。扩容会重新计算桶位置，并重新分配键值对，以保持桶的平均长度较短，提高查询效率。</p></li>
</ol>
<p><strong>JDK 1.8及以后的HashMap结构及原理：</strong></p>
<p>在JDK
1.8及以后，HashMap的内部结构进行了改进，主要包含以下几个方面的优化：</p>
<ol type="1">
<li><p>数组+链表/红黑树：当链表中的元素数量超过一定阈值（默认为8），链表会自动转换为平衡的红黑树结构，以提高在链表长度较长时的查询效率。</p></li>
<li><p>红黑树（Red-Black
Tree）：红黑树是一种自平衡的二叉搜索树，它在平均和最坏情况下都能提供O(log
n)的查询、插入和删除操作。</p></li>
<li><p>链表优化：JDK
1.8中对链表的实现进行了优化，使用了尾插法（插入在链表末尾）和批量操作等技术来提高性能。</p></li>
<li><p>优化哈希算法：JDK
1.8中对哈希算法进行了改进，减少了哈希碰撞的概率，提高了性能。</p></li>
<li><p>并发安全性：JDK
1.8中引入了线程安全的HashMap实现，即ConcurrentHashMap，用于在并发环境下安全地操作HashMap。</p></li>
</ol>
<p>总体而言，JDK
1.8及以后的HashMap在性能和功能上相较于之前的版本有所提升。通过优化链表结构和引入红黑树，</p>
</blockquote>
<ul>
<li><h3 id="hashmap一边扩容一边add会发生什么样的情况">Hashmap一边扩容一边add会发生什么样的情况</h3></li>
</ul>
<blockquote>
<p>当HashMap在扩容的过程中同时有新的元素添加时，会发生以下情况：</p>
<ol type="1">
<li><p>扩容开始：HashMap在达到负载因子（Load
Factor）阈值时触发扩容操作。扩容会创建一个更大的哈希表，并将原有的元素重新分配到新的哈希表中。</p></li>
<li><p>并发修改问题：在扩容过程中，如果有新的元素添加到HashMap中，会出现并发修改的问题。由于扩容是一个耗时的操作，当新的元素添加时，可能存在同时进行扩容的情况。</p></li>
<li><p>分配到新的哈希表：新的元素添加时，会被分配到新的哈希表中。新的哈希表会根据元素的哈希值重新计算索引位置，并将元素放置在对应的位置上。</p></li>
<li><p>原有元素的迁移：扩容过程中，会将原有的元素从旧的哈希表中复制到新的哈希表中。这个过程可能会涉及到元素的重新哈希计算和位置的调整。</p></li>
<li><p>并发安全：HashMap在扩容时会通过synchronized关键字来保证线程安全，确保在扩容过程中不会导致数据的丢失或者错误的访问。但是并发修改仍然会引起性能问题。</p></li>
</ol>
<p>总结起来，当HashMap在扩容的过程中同时有新的元素添加时，会导致并发修改的问题，并且可能会影响性能。为了避免这种情况，可以使用并发安全的数据结构，如ConcurrentHashMap，或者在多线程环境下使用同步机制来保证线程安全。</p>
</blockquote>
<ul>
<li><h3 id="hash索引-b树索引">hash索引 B+树索引</h3></li>
</ul>
<blockquote>
<p>Hash索引和B+树索引是常见的数据库索引结构，它们在实现原理和适用场景上有所区别。</p>
<ol type="1">
<li>Hash索引：
<ul>
<li>原理：Hash索引使用哈希函数将索引列的值映射为索引项的存储地址，通过直接访问存储地址来快速定位数据。</li>
<li>特点：
<ul>
<li>查找效率高，通常具有O(1)的复杂度，即常数级别的查询性能。</li>
<li>适用于等值查询，如根据主键或唯一键查找数据。</li>
<li>不支持范围查询和排序操作。</li>
<li>对于哈希冲突的处理，常见的方式是使用链表或开放寻址法解决冲突。</li>
</ul></li>
<li>适用场景：
<ul>
<li>需要快速的等值查询，对于频繁的查找操作性能较好。</li>
<li>数据访问模式较为简单，不需要进行范围查询或排序操作。</li>
</ul></li>
</ul></li>
<li>B+树索引：
<ul>
<li>原理：B+树索引是一种平衡多路搜索树的数据结构，通过在每个节点上存储多个关键字和指针，形成多层次的索引结构，从而实现高效的数据查找。</li>
<li>特点：
<ul>
<li>支持范围查询和排序操作，适用于范围查询、模糊查询和排序操作等复杂查询。</li>
<li>对于数据的插入和删除操作，维护平衡树结构的成本相对较高。</li>
<li>叶子节点形成有序链表，方便范围查询和顺序访问。</li>
<li>内部节点仅用于索引，不存储实际数据。</li>
</ul></li>
<li>适用场景：
<ul>
<li>数据访问模式复杂，需要支持范围查询、模糊查询和排序操作。</li>
<li>数据的插入和删除操作不是特别频繁，而是以查询为主。</li>
</ul></li>
</ul></li>
</ol>
<p>总体来说，Hash索引适用于等值查询，具有快速的查询速度，但不支持范围查询和排序操作。B+树索引适用于复杂的查询模式，支持范围查询和排序操作，但对于插入和删除操作的成本较高。根据具体的业务需求和数据访问模式，可以选择合适的索引结构来提高查询性能。</p>
</blockquote>
<ul>
<li><h3 id="集合">集合</h3></li>
</ul>
<blockquote>
<p>在Java中，集合（Collections）是一组对象的容器，用于存储、管理和操作一组相关的元素。Java提供了多种集合接口和实现类，每种集合类型都有不同的特性和用途。</p>
<p>主要的集合分类如下：</p>
<ol type="1">
<li>List（列表）：
<ul>
<li>特点：有序集合，允许存储重复元素。</li>
<li>实现类：ArrayList、LinkedList、Vector。</li>
<li>使用场景：需要保留元素的插入顺序，需要频繁访问和修改元素的场景。</li>
</ul></li>
<li>Set（集）：
<ul>
<li>特点：不允许存储重复元素。</li>
<li>实现类：HashSet、TreeSet、LinkedHashSet。</li>
<li>使用场景：去重、判断元素是否存在的场景。</li>
</ul></li>
<li>Queue（队列）：
<ul>
<li>特点：遵循先进先出（FIFO）原则。</li>
<li>实现类：LinkedList、PriorityQueue、ArrayDeque。</li>
<li>使用场景：实现任务调度、消息传递等场景。</li>
</ul></li>
<li>Map（映射）：
<ul>
<li>特点：键值对的集合，根据键快速查找对应的值，键不允许重复。</li>
<li>实现类：HashMap、TreeMap、LinkedHashMap、Hashtable、ConcurrentHashMap。</li>
<li>使用场景：存储具有唯一标识的数据、快速查找、缓存等场景。</li>
</ul></li>
</ol>
<p>每种集合类型都有不同的实现类，其中常用的实现类及其作用和使用场景如下：</p>
<ol type="1">
<li>ArrayList：
<ul>
<li>作用：基于动态数组实现的列表，支持快速随机访问和增删操作。</li>
<li>使用场景：需要快速随机访问和频繁增删元素的场景。</li>
</ul></li>
<li>LinkedList：
<ul>
<li>作用：基于双向链表实现的列表，支持高效的插入和删除操作。</li>
<li>使用场景：需要频繁插入和删除元素的场景。</li>
</ul></li>
<li>HashSet：
<ul>
<li>作用：基于哈希表实现的集，提供快速的插入、删除和查找操作，不保证元素的顺序。</li>
<li>使用场景：需要快速查找和去重的场景。</li>
</ul></li>
<li>TreeSet：
<ul>
<li>作用：基于红黑树实现的有序集，提供有序的元素访问和高效的范围查找操作。</li>
<li>使用场景：需要有序访问和范围查找的场景。</li>
</ul></li>
<li>HashMap：
<ul>
<li>作用：基于哈希表实现的映射，提供高效的插入、删除和查找操作，不保证元素的顺序。</li>
<li>使用场景：存储键值对且需要快速查找和根据键进行操作的场景。</li>
</ul></li>
<li>TreeMap：
<ul>
<li>作用：基于红黑树实现的有序映</li>
</ul></li>
<li>LinkedHashMap：
<ul>
<li>作用：基于哈希表和双向链表实现的有序映射，提供有序的元素访问和高效的插入、删除操作。</li>
<li>使用场景：需要保持元素插入顺序或访问顺序的场景。</li>
</ul></li>
<li>Vector：
<ul>
<li>作用：类似于ArrayList，是线程安全的动态数组。</li>
<li>使用场景：多线程环境下需要安全操作的场景。</li>
</ul></li>
<li>Hashtable：
<ul>
<li>作用：类似于HashMap，是线程安全的哈希表。</li>
<li>使用场景：多线程环境下需要安全操作的场景。</li>
</ul></li>
<li>PriorityQueue：
<ul>
<li>作用：基于优先级堆实现的队列，元素按照优先级顺序出队。</li>
<li>使用场景：实现任务调度、优先级队列等场景。</li>
</ul></li>
<li>ArrayDeque：
<ul>
<li>作用：基于动态数组实现的双端队列，可以在队列的两端进行插入和删除操作。</li>
<li>使用场景：需要在队列两端高效插入和删除元素的场景。</li>
</ul></li>
<li>ConcurrentHashMap：
<ul>
<li>作用：线程安全的哈希表，支持高并发操作。</li>
<li>使用场景：多线程环境下需要高并发操作和安全性的场景。</li>
</ul></li>
</ol>
</blockquote>
<ul>
<li><h3 id="synchronize和lock的区别">Synchronize和Lock的区别</h3></li>
</ul>
<blockquote>
<p>synchronized关键字和Lock接口是Java中用于实现线程同步的两种机制，它们有以下区别：</p>
<ol type="1">
<li>锁的获取和释放方式：
<ul>
<li>synchronized：隐式获取和释放锁。线程进入synchronized代码块或方法时，会自动获取锁，并在退出时释放锁。</li>
<li>Lock：显式获取和释放锁。需要手动调用Lock接口的lock()方法获取锁，并在不需要锁时调用unlock()方法释放锁。</li>
</ul></li>
<li>粒度：
<ul>
<li>synchronized：对整个方法或代码块进行加锁。一次只能有一个线程获得锁，其他线程需要等待。</li>
<li>Lock：可以根据需求对代码块进行更细粒度的加锁。例如，使用Lock的tryLock()方法可以尝试获取锁，如果锁被其他线程持有，则返回失败，而不是一直阻塞等待。</li>
</ul></li>
<li>可中断性：
<ul>
<li>synchronized：获取到锁后，线程无法被中断，除非获取锁的线程自己主动释放锁或执行完毕。</li>
<li>Lock：Lock接口提供了lockInterruptibly()方法，允许在获取锁的过程中被中断。</li>
</ul></li>
<li>等待可中断：
<ul>
<li>synchronized：线程在获取锁失败时，会进入阻塞状态，直到获取到锁。</li>
<li>Lock：Lock接口提供了Condition对象，可以使用await()方法在等待时进入阻塞状态，并且可以通过signal()或signalAll()方法唤醒等待的线程。</li>
</ul></li>
<li>锁的公平性：
<ul>
<li>synchronized：不保证公平性，无法指定线程获取锁的顺序。</li>
<li>Lock：通过构造函数可以指定为公平锁或非公平锁。公平锁会按照线程请求的顺序分配锁。</li>
</ul></li>
<li>功能扩展：
<ul>
<li>synchronized：Java内置的关键字，无法扩展。</li>
<li>Lock：Lock接口提供了更多的功能扩展，例如可重入锁、读写锁等。</li>
</ul></li>
</ol>
<p>总的来说，synchronized关键字是Java中最基本和常用的线程同步机制，使用简单方便，适用于大多数场景。而Lock接口提供了更多的灵活性和扩展性，适用于需要更细粒度控制、可中断等特性的场景。在性能要求较高或对锁的粒度要求较细的情况下，可以考虑使用Lock接口。</p>
</blockquote>
<ul>
<li><h3 id="异常">异常</h3></li>
</ul>
<blockquote>
<p>异常是在程序执行过程中发生的意外或异常情况。在Java中，异常分为两类：<a href="#检查时异常">可检查异常</a>（Checked
Exception）和不可检查异常（Unchecked Exception）。</p>
<ol type="1">
<li>可检查异常（Checked Exception）：
<ul>
<li>可检查异常是指在编译时必须进行处理的异常，要么通过try-catch语句捕获并处理，要么在方法签名中使用throws关键字声明将异常向上抛出。</li>
<li>一般是程序中的错误或异常情况，需要进行处理以确保程序的正确执行。</li>
<li>一些常见的可检查异常有：IOException、SQLException、ClassNotFoundException等。</li>
</ul></li>
<li>不可检查异常（Unchecked Exception）：
<ul>
<li>不可检查异常是指在编译时不要求必须处理的异常，也不需要在方法签名中声明，通常是由程序逻辑错误或运行环境导致的。</li>
<li>不可检查异常通常是RuntimeException及其子类，包括NullPointerException、IllegalArgumentException、ArrayIndexOutOfBoundsException等。</li>
<li>不可检查异常不需要强制捕获或声明，但可以自行选择进行捕获和处理。</li>
</ul></li>
</ol>
<p>除了这两类基本的异常类型，Java还提供了一些特殊的异常：</p>
<ul>
<li>Error：Error是指程序无法处理的错误，通常是由JVM或系统级别的问题引起的，例如OutOfMemoryError、StackOverflowError等。一般情况下，不需要捕获或处理Error，因为它们表示严重问题，无法恢复。</li>
<li>RuntimeException的子类：除了上述提到的RuntimeException及其子类外，还有一些其他的RuntimeException的子类异常，如ClassCastException、IllegalStateException等。</li>
</ul>
<p>在处理异常时，通常的做法是使用try-catch语句来捕获并处理异常，或者使用throws关键字在方法签名中声明将异常向上抛出，由上层调用者来处理异常。捕获和处理异常可以帮助程序正确地处理错误情况，避免程序崩溃或产生不可预料的结果。</p>
<p>需要根据具体的业务逻辑和需求，选择合适的异常处理策略，合理处理异常可以提高程序的健壮性和可靠性</p>
</blockquote>
<ul>
<li><h3 id="检查时异常">检查时异常</h3></li>
</ul>
<blockquote>
<p>可检查异常（Checked
Exception）是在编译时必须进行处理的异常，要么通过try-catch语句捕获并处理，要么在方法签名中使用throws关键字声明将异常向上抛出。以下是一些常见的可检查异常及其说明：</p>
<ol type="1">
<li><p>IOException：表示输入输出操作中的异常，如文件读写错误、网络连接问题等。</p></li>
<li><p>SQLException：表示与数据库相关的异常，如连接数据库失败、执行SQL语句错误等。</p></li>
<li><p>ClassNotFoundException：表示找不到指定类的异常，通常在使用反射或动态加载类时抛出。</p></li>
<li><p>InterruptedException：表示线程在等待、休眠或阻塞状态时被中断的异常。</p></li>
<li><p>FileNotFoundException：表示指定文件不存在的异常。</p></li>
<li><p>MalformedURLException：表示URL格式错误的异常。</p></li>
<li><p>ParseException：表示解析字符串、日期等格式错误的异常。</p></li>
<li><p>NamingException：表示与命名和目录服务相关的异常，如在访问LDAP（轻量级目录访问协议）时出错。</p></li>
<li><p>ClassNotFoundException：表示无法找到类或接口的异常，通常发生在使用Class.forName()加载类时。</p></li>
<li><p>IOException：表示输入输出操作中的异常，如读写文件、网络操作等。</p></li>
</ol>
<p>这些是常见的可检查异常，对于这些异常，编译器要求在编译时进行处理，以确保程序的健壮性和可靠性。处理可检查异常可以选择捕获并处理异常，或者在方法签名中使用throws关键字声明将异常向上抛出。</p>
<p>处理可检查异常的方式通常包括以下几种：</p>
<ul>
<li>使用try-catch语句捕获并处理异常，以提供针对异常情况的逻辑处理。</li>
<li>在方法签名中使用throws关键字声明将异常向上抛出，让上层调用者处理异常。</li>
</ul>
<p>需要根据具体的业务逻辑和需求，选择适当的处理方式来处理可检查异常，以确保程序的正确性和稳定性。</p>
</blockquote>
<ul>
<li><h3 id="泛型">泛型</h3></li>
</ul>
<blockquote>
<p>泛型（Generics）是Java语言引入的一项特性，用于增强类型安全性和代码的重用性。它允许我们在定义类、接口和方法时使用类型参数，从而使这些类型可以在使用时指定具体的类型。</p>
<p>泛型的主要优势包括：</p>
<ol type="1">
<li>类型安全：通过使用泛型，可以在编译时检测和捕获类型错误，避免在运行时出现类型转换异常。</li>
<li>代码重用：可以编写通用的代码逻辑，可以在不同的数据类型上重复使用，提高代码的可重用性。</li>
<li>提升性能：避免了不必要的类型转换，可以提升程序的执行效率。</li>
<li>简化代码：使用泛型可以减少代码中的重复和冗余，提高代码的简洁性和可读性。</li>
</ol>
<p>在Java中，泛型主要有以下几种用法：</p>
<ol type="1">
<li><p>类泛型（Generic
Class）：在类的定义中使用泛型参数，用于指定类中使用的类型。例如，<code>class MyClass&lt;T&gt;</code>表示一个泛型类，其中T表示类型参数。</p></li>
<li><p>接口泛型（Generic
Interface）：在接口的定义中使用泛型参数，用于指定接口中使用的类型。</p></li>
<li><p>方法泛型（Generic
Method）：在方法的定义中使用泛型参数，用于指定方法中使用的类型。</p></li>
<li><p>通配符（Wildcard）：使用通配符（<code>?</code>）表示未知类型，用于在泛型中指定一种范围内的类型。</p></li>
<li><p>类型限定（Type
Bounds）：通过使用类型限定，可以限制泛型参数的类型范围，可以是类、接口或它们的组合。</p></li>
</ol>
<p>泛型的使用可以提高代码的可读性和可维护性，并帮助我们编写更加通用和类型安全的代码。通过使用泛型，我们可以在编译时进行类型检查，避免在运行时出现类型错误，提高程序的稳定性和可靠性。</p>
</blockquote>
<ul>
<li><h3 id="泛型通配符">泛型通配符</h3></li>
</ul>
<blockquote>
<p>泛型通配符（Wildcard）是泛型中的一种特殊用法，用于表示未知的类型或类型的范围。在Java中，有两种主要的泛型通配符：问号（<code>?</code>）和上界通配符（<code>extends</code>关键字）。</p>
<ol type="1">
<li>问号通配符（<code>?</code>）：
<ul>
<li>问号通配符表示一种未知的类型，可以用于表示任意类型的参数化类型。例如，<code>List&lt;?&gt;</code>表示一个元素类型未知的列表。</li>
<li>问号通配符通常用于读取数据，表示可以接受任意类型的参数，但在使用时无法确定具体的类型。</li>
<li>问号通配符不能用于写入数据，因为编译器无法确定要写入的类型是什么。</li>
</ul></li>
<li>上界通配符（<code>extends</code>关键字）：
<ul>
<li>上界通配符用于限制泛型类型的范围，表示参数化类型必须是指定类型或指定类型的子类。</li>
<li>通过使用<code>extends</code>关键字，可以指定参数化类型的上界。例如，<code>List&lt;? extends Number&gt;</code>表示一个元素类型必须是Number或Number的子类的列表。</li>
<li>上界通配符在读取数据和写入数据时都有一定的限制，可以安全地读取指定类型或其子类的数据，但无法写入数据。</li>
</ul></li>
</ol>
<p>泛型通配符的使用可以增加代码的灵活性和可复用性，使得代码可以处理不同类型的参数化类型。通过通配符的灵活性，我们可以编写更加通用的代码，并在不同的情况下使用相同的逻辑处理不同的参数类型。</p>
<p>需要注意的是，泛型通配符并不能用于创建泛型实例，因为编译器无法确定具体的类型。它主要用于泛型方法的参数声明、泛型类或接口的定义中，以及在方法中对泛型类型进行操作时的类型限定。</p>
</blockquote>
<ul>
<li>日期的类(date,dateformat,日历类)</li>
</ul>
<blockquote>
<p>在Java中，用于处理日期和时间的主要类包括
<code>Date</code>、<code>DateFormat</code> 和
<code>Calendar</code>。</p>
<ol type="1">
<li><code>Date</code> 类：
<ul>
<li><code>Date</code> 类是 Java
提供的用于表示日期和时间的类。它包含了日期和时间的信息，可以表示从1970年1月1日
00:00:00 GMT 开始的毫秒数。</li>
<li><code>Date</code>
类提供了一些方法用于获取和设置日期和时间的不同部分，例如年、月、日、小时、分钟、秒等。</li>
<li>注意：<code>Date</code> 类在 Java 8 中已经过时，推荐使用
<code>java.time</code> 包中的日期和时间类。</li>
</ul></li>
<li><code>DateFormat</code> 类：
<ul>
<li><code>DateFormat</code>
类是抽象类，用于格式化和解析日期和时间的字符串表示。</li>
<li>可以使用 <code>SimpleDateFormat</code>
类来实现具体的日期格式化和解析，通过指定格式模式字符串，将日期对象转换为字符串，或将字符串解析为日期对象。</li>
<li><code>DateFormat</code>
类还提供了一些方法用于在日期和字符串之间进行转换，例如
<code>format()</code> 方法用于格式化日期，<code>parse()</code>
方法用于解析字符串为日期。</li>
</ul></li>
<li><code>Calendar</code> 类：
<ul>
<li><code>Calendar</code>
类是一个抽象类，用于处理日期和时间的计算和操作。</li>
<li>通过 <code>Calendar</code>
类，可以获取和设置年、月、日、小时、分钟、秒等日期和时间的各个部分。</li>
<li><code>Calendar</code>
类提供了一些方法用于执行日期和时间的计算，例如添加或减去指定的时间间隔，比较两个日期等。</li>
<li><code>Calendar</code> 类还提供了 <code>getInstance()</code>
静态方法用于获取当前系统默认时区的 <code>Calendar</code> 实例。</li>
</ul></li>
</ol>
<p>这些日期相关的类提供了丰富的方法和功能，用于处理日期和时间的表示、格式化、解析以及日期计算等操作。通过它们，可以方便地处理和操作日期和时间，并满足不同的业务需求。在
Java 8 及更高版本中，还引入了新的日期和时间 API（<code>java.time</code>
包），提供了更加全面和易用的日期和时间处理功能。</p>
</blockquote>
<ul>
<li><h3 id="runnable和callable的区别">runnable和callable的区别(!)</h3></li>
</ul>
<blockquote>
<p><code>Runnable</code> 和 <code>Callable</code> 是 Java
多线程编程中用于并发执行任务的两个接口，它们之间有以下主要区别：</p>
<ol type="1">
<li><p>返回值类型：<code>Runnable</code> 接口没有返回值，其
<code>run()</code> 方法的返回类型为 <code>void</code>。而
<code>Callable</code> 接口的 <code>call()</code>
方法可以返回一个结果，并且可以指定返回值的类型。</p></li>
<li><p>异常处理：<code>Runnable</code> 的 <code>run()</code>
方法不能抛出已检查异常，只能捕获处理或者在方法签名中使用
<code>throws</code> 关键字声明未检查异常。而 <code>Callable</code> 的
<code>call()</code>
方法可以抛出已检查异常，调用者需要捕获处理。</p></li>
<li><p>使用方式：<code>Runnable</code>
接口适用于无需返回结果的简单任务，通常通过创建 <code>Thread</code>
对象来执行。而 <code>Callable</code>
接口适用于需要返回结果的任务，通常需要结合 <code>ExecutorService</code>
的线程池来执行，并通过 <code>Future</code> 对象获取结果。</p></li>
<li><p>多线程执行：<code>Runnable</code>
可以由多个线程并发执行，但是没有返回结果。<code>Callable</code>
只能由一个线程执行，但是可以返回一个结果。</p></li>
<li><p>泛型支持：<code>Callable</code> 接口定义了泛型类型参数，可以指定
<code>call()</code> 方法的返回值类型。而 <code>Runnable</code>
接口没有泛型参数。</p></li>
</ol>
<p>综上所述，<code>Runnable</code>
接口主要用于执行无返回结果的简单任务，而 <code>Callable</code>
接口则适用于需要返回结果的任务。根据具体的需求，选择适当的接口来实现多线程任务。</p>
</blockquote>
<ul>
<li>线程池7大参数</li>
</ul>
<blockquote>
<p>在 Java 中，线程池的创建和配置可以通过
<code>ThreadPoolExecutor</code>
类来完成。<code>ThreadPoolExecutor</code>
类提供了一系列的构造方法和设置方法，用于配置线程池的参数。以下是线程池的七个主要参数：</p>
<ol type="1">
<li>核心线程数（corePoolSize）：
<ul>
<li>核心线程数是线程池中保持活动状态的线程数量。</li>
<li>在没有任务执行时，核心线程也会一直存活，不会被回收。</li>
<li>新任务的提交会创建新的核心线程，直到核心线程数达到设定的值。</li>
</ul></li>
<li>最大线程数（maximumPoolSize）：
<ul>
<li>最大线程数是线程池中允许存在的最大线程数量，包括核心线程和非核心线程。</li>
<li>当任务提交数量超过核心线程数且等待队列已满时，会创建新的非核心线程来执行任务。</li>
<li>最大线程数的设定需要根据系统资源和任务负载情况来合理调整。</li>
</ul></li>
<li>空闲线程存活时间（keepAliveTime）：
<ul>
<li>空闲线程存活时间指的是当线程池中的线程数量超过核心线程数时，多余的空闲线程在没有任务可执行时保持存活的时间。</li>
<li>超过该时间后，空闲线程将会被回收。</li>
</ul></li>
<li>时间单位（unit）：
<ul>
<li>时间单位用于指定参数 keepAliveTime 的时间单位，例如
TimeUnit.SECONDS、TimeUnit.MINUTES 等。</li>
</ul></li>
<li>任务队列（workQueue）：
<ul>
<li>任务队列用于存储等待执行的任务。</li>
<li>可以选择不同类型的任务队列，如
ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue
等，具体选择根据任务的特点和需求来决定。</li>
</ul></li>
<li>线程工厂（threadFactory）：
<ul>
<li>线程工厂用于创建新的线程。</li>
<li>可以通过自定义线程工厂来对线程进行定制，如指定线程名称、设置线程优先级等。</li>
</ul></li>
<li>拒绝策略（rejectedExecutionHandler）：
<ul>
<li>当线程池和任务队列都满了，无法继续执行新任务时，拒绝策略决定如何处理这些被拒绝的任务。</li>
<li>Java 提供了几种内置的拒绝策略，如
AbortPolicy、CallerRunsPolicy、DiscardPolicy 和
DiscardOldestPolicy，也可以自定义拒绝策略。</li>
</ul></li>
</ol>
<p>以上七个参数共同决定了线程池的行为和性能。合理地配置这些参数可以有效控制线程池的资源消耗、任务执行效率和并发度。</p>
</blockquote>
<ul>
<li>参数中线程数设置多少(可以从CPU密集型和IO密集型讲)</li>
</ul>
<blockquote>
<p>线程数的设置需要根据具体的应用场景和系统资源进行评估和调整，特别是在区分
CPU 密集型和 I/O 密集型任务时，需要考虑不同的因素。</p>
<ol type="1">
<li>CPU 密集型任务：
<ul>
<li>对于 CPU 密集型任务，它们主要消耗 CPU 资源而不涉及大量的 I/O
操作。在这种情况下，线程数的设置应该考虑到 CPU
的物理核心数量。通常情况下，可以设置与 CPU
核心数相当的线程数。这样可以充分利用 CPU
的计算能力，避免线程竞争和上下文切换的开销。</li>
</ul></li>
<li>I/O 密集型任务：
<ul>
<li>对于 I/O 密集型任务，它们主要涉及大量的 I/O
操作，如文件读写、网络请求等。在这种情况下，线程数的设置应该考虑到 I/O
操作的耗时和并发能力。通常情况下，可以设置比 CPU
核心数更多的线程数，以充分利用 CPU 在等待 I/O
操作时的空闲时间，提高系统的并发能力。同时，需要注意过多的线程数可能会导致系统资源的浪费和线程间的竞争。</li>
</ul></li>
</ol>
<p>总的来说，线程数的设置需要根据实际情况进行测试和调优。可以根据系统的负载情况、资源利用率和响应时间等指标进行评估，逐步增加或减少线程数，找到最佳的性能和吞吐量的平衡点。</p>
<p>此外，还可以考虑使用线程池来管理线程，线程池可以根据实际情况动态地调整线程数，提供线程的复用和管理，避免频繁地创建和销毁线程，提高系统的性能和资源利用率。</p>
</blockquote>
<ul>
<li><h3 id="常用的垃圾回收器">常用的垃圾回收器</h3></li>
</ul>
<blockquote>
<p>在Java虚拟机中，常用的<a href="#gc流程">垃圾回收器</a>有以下几种：</p>
<ol type="1">
<li><p>Serial收集器：Serial收集器是一种单线程的垃圾回收器，它会暂停所有应用线程来进行垃圾回收。它适用于单核或小型应用场景。</p></li>
<li><p>Parallel收集器：Parallel收集器是一种多线程的垃圾回收器，它使用多个线程并行地进行垃圾回收，提高回收效率。它适用于多核CPU的应用场景。</p></li>
<li><p>CMS（Concurrent Mark
Sweep）收集器：CMS收集器是一种以获取最短回收停顿时间为目标的垃圾回收器。它通过多线程并发地标记和清理垃圾对象，减少回收停顿时间。它适用于对响应时间有要求的应用场景。</p></li>
<li><p>G1（Garbage-First）收集器：G1收集器是一种面向服务器应用的垃圾回收器。它采用分代收集和并发标记清除的策略，可以有效地控制回收停顿时间，并具有可预测的性能特性。它适用于大内存、低延迟和高吞吐量的应用场景。</p></li>
</ol>
<p>以上是常见的几种垃圾回收器，每种回收器都有其特定的优点和适用场景。在实际应用中，可以根据应用的需求和系统的资源情况选择合适的垃圾回收器。同时，可以通过调整垃圾回收器的参数来优化垃圾回收性能和系统的吞吐量。</p>
</blockquote>
<ul>
<li><h3 id="垃圾回收器的组合使用">垃圾回收器的组合使用(!)</h3></li>
</ul>
<blockquote>
<p>在Java虚拟机中，可以通过配置不同的垃圾回收器来组合使用，以达到更好的性能和吞吐量。下面是一些常见的垃圾回收器组合：</p>
<ol type="1">
<li><p>Serial + Serial
Old：这是最简单的组合，使用Serial收集器进行新生代的垃圾回收，使用Serial
Old收集器进行老年代的垃圾回收。适用于单核或小型应用场景。</p></li>
<li><p>Parallel Scavenge + Serial Old：使用Parallel
Scavenge收集器进行新生代的垃圾回收，使用Serial
Old收集器进行老年代的垃圾回收。适用于多核CPU的应用场景。</p></li>
<li><p>Parallel Scavenge + Parallel Old：使用Parallel
Scavenge收集器进行新生代的垃圾回收，使用Parallel
Old收集器进行老年代的垃圾回收。适用于多核CPU的应用场景，并且对吞吐量有较高要求。</p></li>
<li><p>CMS（Concurrent Mark Sweep）：CMS收集器可以与Serial、Parallel
Scavenge或Parallel
Old进行组合使用。CMS收集器使用并发的方式进行垃圾回收，可以减少回收停顿时间。适用于对响应时间有要求的应用场景。</p></li>
<li><p>G1（Garbage-First）：G1收集器可以单独使用，也可以与CMS或Parallel
Old进行组合使用。G1收集器适用于大内存、低延迟和高吞吐量的应用场景。</p></li>
</ol>
<p>垃圾回收器的组合使用可以根据具体的应用需求和系统配置进行选择。通过合理地组合和调整垃圾回收器，可以达到更好的性能、更低的停顿时间和更高的吞吐量。需要注意的是，不同的垃圾回收器组合可能会带来不同的调优参数和配置要求，需要综合考虑并进行实际测试和评估。</p>
</blockquote>
<ul>
<li><h3 id="jvm的运行数据区的组成">JVM的运行数据区的组成</h3></li>
</ul>
<blockquote>
<p>JVM的运行数据区主要由以下几个组成部分：</p>
<ol type="1">
<li><p>方法区（Method
Area）：方法区是线程共享的内存区域，用于存储类的结构信息、常量、静态变量等数据。在JDK
8及之前的版本中，方法区被实现为永久代（PermGen）；而在JDK
8及以后的版本中，方法区被实现为元空间（Metaspace）。</p></li>
<li><p>堆（Heap）：堆是用于存储对象实例的内存区域，是Java程序中最大的一块内存区域。堆被所有线程共享，用于存放动态创建的对象。在堆中，对象可以被自动进行垃圾回收。堆可以分为新生代（Young
Generation）和老年代（Old Generation）两部分。</p></li>
<li><p>虚拟机栈（VM
Stack）：虚拟机栈用于存储线程的方法调用栈和局部变量表。每个线程在运行时都会创建一个对应的虚拟机栈，用于存储方法的局部变量、操作数栈等信息。</p></li>
<li><p>本地方法栈（Native Method
Stack）：本地方法栈类似于虚拟机栈，但是用于执行本地方法（由C或C++等语言编写的方法）。</p></li>
<li><p>程序计数器（Program Counter
Register）：程序计数器是每个线程私有的，用于记录当前线程执行的字节码指令的地址或索引。在线程切换时，程序计数器用于恢复线程的执行位置。</p></li>
</ol>
<p>除了上述运行数据区，JVM还包括了一些其他重要的组件，如执行引擎、本地方法接口、本地库接口等，用于支持Java程序的运行和调用底层系统资源。</p>
<p>这些运行数据区的组成保证了Java程序的运行环境和内存管理机制，不同的区域有不同的作用和管理策略，通过合理地管理和调优这些区域，可以提高Java程序的性能和效率。</p>
</blockquote>
<ul>
<li>如果多线程对一个变量进行操作，有什么方法实现锁</li>
</ul>
<blockquote>
<p>在多线程环境下，可以使用以下方法实现对共享变量的锁定，以保证线程安全：</p>
<ol type="1">
<li><p>使用 synchronized 关键字：通过在方法或代码块上添加 synchronized
关键字，可以将代码块标记为同步代码块，只允许一个线程进入执行该代码块，其他线程需要等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synchronizedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 同步代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 ReentrantLock 类：ReentrantLock 是 JDK
提供的可重入锁，通过调用 lock() 方法获取锁，调用 unlock()
方法释放锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 synchronized 关键字或 ReentrantLock
的锁对象：可以使用一个共享的对象作为锁对象，多个线程在访问共享变量时，使用该锁对象进行同步操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">      </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些方法都可以实现对共享变量的锁定，确保在同一时间只有一个线程能够访问共享变量，从而避免数据竞争和线程安全问题。需要根据具体的场景和需求选择合适的锁机制，以保证线程安全和性能。</p>
</blockquote>
<ul>
<li><h3 id="线程间的信息如何传递的">线程间的信息如何传递的</h3></li>
</ul>
<blockquote>
<p>线程间的信息传递可以通过以下几种方式实现：</p>
<ol type="1">
<li><p>共享变量：线程之间可以通过共享变量来传递信息。多个线程可以访问和修改同一个共享变量，通过对共享变量的读写操作来实现信息的传递。然而，需要注意的是在多线程环境下，共享变量可能存在线程安全的问题，需要采取同步机制来保证线程安全性。</p></li>
<li><p>线程间的通信：Java提供了多种线程间的通信机制，如wait()、notify()、notifyAll()等方法，可以通过这些方法在线程之间进行信息的传递和同步。通过调用wait()方法，线程可以等待某个条件满足后再继续执行，而其他线程可以通过notify()或notifyAll()方法来唤醒等待的线程。</p></li>
<li><p>队列（Queue）：线程之间可以通过队列来传递信息。一个线程可以将信息放入队列，而另一个线程可以从队列中取出信息。常见的队列实现包括阻塞队列（如ArrayBlockingQueue、LinkedBlockingQueue）和并发队列（如ConcurrentLinkedQueue、LinkedTransferQueue），它们提供了线程安全的操作和同步机制。</p></li>
<li><p>线程池：线程池可以将任务提交到线程池中执行，并返回Future对象作为任务的结果。通过Future对象，线程可以获取任务执行的结果或取消任务的执行。线程池可以实现线程间的信息传递，主线程可以将任务提交给线程池，而各个工作线程可以执行任务并返回结果。</p></li>
</ol>
<p>这些方法和机制可以根据具体的需求和场景选择使用，其中每种方式都有其适用的场景和注意事项。在多线程编程中，需要考虑线程安全性和同步机制，以确保线程间的信息传递正确、可靠和高效。</p>
</blockquote>
<ul>
<li>java8新特性</li>
</ul>
<blockquote>
<p>Java 8引入了许多新的特性和改进，以下是Java 8的一些主要特性：</p>
<ol type="1">
<li><p>Lambda表达式：Lambda表达式允许以更简洁的语法编写函数式接口的实现，使代码更具可读性和简洁性。</p></li>
<li><p>方法引用：方法引用提供了一种更简洁的方式来直接引用已经存在的方法或构造函数。</p></li>
<li><p>函数式接口：Java
8引入了函数式接口，即只包含一个抽象方法的接口。函数式接口与Lambda表达式和方法引用一起使用，可以简化代码并提高可读性。</p></li>
<li><p>Stream API：Stream
API提供了一种函数式编程的方式来操作集合数据。通过使用Stream
API，可以对集合进行过滤、映射、排序等操作，使代码更简洁、可读性更高。</p></li>
<li><p>默认方法：Java
8允许在接口中定义默认方法，即在接口中可以提供默认的方法实现。这样，在接口的所有实现类中都会有这个默认实现，避免了对所有实现类进行修改的问题。</p></li>
<li><p>Optional类：Optional类是一个容器类，用于处理可能为null的值。它提供了一种优雅的方式来避免空指针异常，并且可以更清晰地表达一个值是否存在的概念。</p></li>
<li><p>Date/Time API：Java
8引入了全新的日期和时间API（java.time包），提供了更加方便和易用的日期和时间操作方法。</p></li>
<li><p>CompletableFuture类：CompletableFuture类是一种用于异步编程的工具，可以更方便地进行异步操作，并处理操作完成后的结果。</p></li>
<li><p>接口的静态方法和私有方法：Java
8允许在接口中定义静态方法和私有方法，使得接口更加灵活和功能丰富。</p></li>
</ol>
<p>这些是Java
8的一些主要特性，它们为Java开发人员提供了更多的编程选项和更简洁的语法，提高了开发效率和代码质量</p>
</blockquote>
<ul>
<li><h3 id="线程安全的集合类">线程安全的集合类</h3></li>
</ul>
<blockquote>
<p>Java提供了多个线程安全的集合类，可以在多线程环境下安全地进行并发操作。以下是一些常用的线程安全的集合类：</p>
<ol type="1">
<li><p><code>ConcurrentHashMap</code>：线程安全的哈希表，可以用于替代<code>HashMap</code>。支持并发读写，采用分段锁的机制，可以实现更高的并发性能。</p></li>
<li><p><code>CopyOnWriteArrayList</code>：线程安全的动态数组，可以用于替代<code>ArrayList</code>。在写操作时会创建一个新的数组，读操作则不会加锁，因此适用于读多写少的场景。</p></li>
<li><p><code>ConcurrentLinkedQueue</code>：线程安全的链表队列，可以用于替代<code>LinkedList</code>作为队列使用。支持并发的入队和出队操作，适用于高并发的队列场景。</p></li>
<li><p><code>ConcurrentSkipListSet</code>：线程安全的有序集合，基于跳表（Skip
List）数据结构实现。支持并发的插入、删除和查找操作，具有较高的并发性能。</p></li>
<li><p><code>BlockingQueue</code>：阻塞队列的接口，常用的实现类包括<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>等。可以在队列为空或队列已满时进行阻塞操作，实现线程之间的同步。</p></li>
</ol>
<p>这些线程安全的集合类在多线程环境下提供了一定程度的线程安全性，可以避免并发冲突和数据不一致的问题。但需要注意，虽然这些集合类提供了一定的线程安全性，但在特定的业务场景中仍然需要额外的同步措施来保证数据的完整性和一致性。</p>
</blockquote>
<ul>
<li><h3 id="有哪些拒绝策略">有哪些拒绝策略</h3></li>
</ul>
<blockquote>
<p>在Java的线程池中，可以使用以下几种拒绝策略（Rejected Execution
Policy）来处理无法接受新任务的情况：</p>
<ol type="1">
<li><p>AbortPolicy（默认）：当线程池无法接受新任务时，直接抛出<code>RejectedExecutionException</code>异常。</p></li>
<li><p>CallerRunsPolicy：当线程池无法接受新任务时，将任务返回给调用线程来执行。也就是由调用线程自己执行被拒绝的任务。</p></li>
<li><p>DiscardPolicy：当线程池无法接受新任务时，直接丢弃该任务，不做任何处理。</p></li>
<li><p>DiscardOldestPolicy：当线程池无法接受新任务时，先丢弃最早加入队列的任务，然后尝试再次提交新任务。</p></li>
</ol>
<p>除了上述默认提供的拒绝策略，还可以自定义实现<code>RejectedExecutionHandler</code>接口来定义自己的拒绝策略。通过实现该接口，并在创建线程池时指定自定义的拒绝策略，可以根据具体需求灵活处理无法接受新任务的情况。</p>
<p>以下是使用自定义拒绝策略的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRejectedExecutionHandler</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义的拒绝策略处理逻辑</span></span><br><span class="line">        <span class="comment">// 可以根据具体需求进行处理，如记录日志、存储未执行的任务等</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Task Rejected: &quot;</span> + r.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池并指定自定义的拒绝策略</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">1</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">CustomRejectedExecutionHandler</span>()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务到线程池</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Task executed.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，自定义的拒绝策略实现了<code>RejectedExecutionHandler</code>接口，并在<code>rejectedExecution()</code>方法中定义了具体的处理逻辑。在创建线程池时，通过<code>ThreadPoolExecutor</code>的构造函数指定了自定义的拒绝策略，当线程池无法接受新任务时，将调用自定义拒绝策略的<code>rejectedExecution()</code>方法进行处理。</p>
</blockquote>
<ul>
<li><h3 id="个线程并发进行怎么保证安全主线程怎么取得每个线程的值">10个线程并发进行怎么保证安全，主线程怎么取得每个线程的值</h3></li>
</ul>
<blockquote>
<p>保证10个线程的并发安全性可以采用以下几种方式：</p>
<ol type="1">
<li><p>使用线程安全的数据结构：在多线程环境下，使用线程安全的数据结构可以确保数据的一致性和并发访问的安全性。例如，使用<code>ConcurrentHashMap</code>代替<code>HashMap</code>，使用<code>ConcurrentLinkedQueue</code>代替<code>LinkedList</code>等。</p></li>
<li><p>使用锁机制：可以使用锁机制来保护共享资源的访问。常用的锁包括<code>synchronized</code>关键字和<code>Lock</code>接口的实现类，如<code>ReentrantLock</code>。通过在关键代码块或方法上加锁，可以保证同一时间只有一个线程可以访问共享资源。</p></li>
<li><p>使用原子操作：Java提供了一些原子类，如<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code>等，可以保证针对共享变量的操作是原子性的，从而避免并发冲突。</p></li>
<li><p>使用并发工具类：Java提供了许多并发工具类，如<code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code>等，可以帮助线程之间进行协作和同步，确保并发操作的安全性。</p></li>
</ol>
<p>为了获取每个线程的值，可以使用<code>Callable</code>接口和<code>Future</code>对象。<code>Callable</code>接口允许线程返回一个结果，而<code>Future</code>对象可以用来获取线程的执行结果。</p>
<p>具体的做法是，将每个线程的任务封装为一个<code>Callable</code>对象，通过<code>ExecutorService</code>提交任务并返回<code>Future</code>对象。然后，主线程可以通过调用<code>Future</code>对象的<code>get()</code>方法来获取每个线程的执行结果。<code>get()</code>方法会阻塞主线程，直到对应的线程任务执行完成并返回结果。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        List&lt;Future&lt;Integer&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Callable&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(i);</span><br><span class="line">            Future&lt;Integer&gt; future = executorService.submit(task);</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取每个线程的执行结果</span></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Integer&gt; future : futures) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread result: &quot;</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> threadNumber;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> threadNumber)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.threadNumber = threadNumber;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 线程的具体任务逻辑</span></span><br><span class="line">            <span class="comment">// 返回线程的结果</span></span><br><span class="line">            <span class="keyword">return</span> threadNumber * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码创建了一个线程池，提交了10个任务，每个任务返回线程编号的两倍。主线程通过遍历<code>Future</code>对象列表，并调用<code>get()</code></p>
</blockquote>
<ul>
<li><h3 id="jvm内存结构">jvm内存结构</h3></li>
</ul>
<blockquote>
<p>JVM（Java虚拟机）的内存结构主要分为以下几个部分：</p>
<ol type="1">
<li><p>方法区（Method
Area）：方法区用于存储类的元数据（如类的结构信息、运行时常量池、字段和方法的描述符等）以及静态变量。在Java
8及之前的版本中，方法区是共享的，被所有线程共享。在Java
8之后，方法区被移除，取而代之的是元空间（Metaspace）。</p></li>
<li><p>堆（Heap）：堆是JVM管理的最大一块内存区域，用于存储对象实例。所有通过new关键字创建的对象都会在堆中分配内存。堆被所有线程共享，但每个线程都有自己的堆栈帧。</p></li>
<li><p>栈（Stack）：栈用于存储线程执行方法的调用栈信息。每个线程在执行方法时，会在栈上创建一个栈帧（Stack
Frame），用于存储方法的局部变量、操作数栈、方法返回值等。栈采用先进后出（LIFO）的数据结构。</p></li>
<li><p>本地方法栈（Native Method
Stack）：本地方法栈类似于栈，但它是为执行本地方法（Native
Method）而设计的。本地方法是使用其他语言（如C、C++）编写的，通过JNI（Java
Native Interface）与Java程序交互。</p></li>
<li><p>程序计数器（Program Counter
Register）：程序计数器是一块较小的内存区域，用于记录当前线程执行的字节码指令地址。每个线程都有自己独立的程序计数器。</p></li>
</ol>
<p>除了上述的主要内存区域外，JVM还有一些其他的内存结构，如直接内存（Direct
Memory）、运行时常量池（Runtime Constant Pool）等。</p>
<p>这些内存区域的划分在JVM规范中定义，不同的JVM实现可能会有一些差异。每个内存区域都有自己的特定作用和管理方式，相互协调工作，以支持Java程序的正常运行和内存管理。</p>
</blockquote>
<ul>
<li><h3 id="类加载机制">类加载机制</h3></li>
</ul>
<blockquote>
<p>类加载机制是指在Java程序运行时，将类的字节码文件加载到内存，并转换成可以直接使用的Java类的过程。Java的类加载机制主要包括以下几个步骤：</p>
<ol type="1">
<li><p>加载（Loading）：将类的字节码文件加载到内存中。加载过程由类加载器（ClassLoader）负责完成。类加载器根据类的全限定名（包名+类名）查找字节码文件，并将其读入内存。</p></li>
<li><p>验证（Verification）：对加载的字节码文件进行验证，确保其符合Java虚拟机规范。验证过程包括文件格式验证、元数据验证、字节码验证和符号引用验证。</p></li>
<li><p>准备（Preparation）：为类的静态变量分配内存，并设置初始值。静态变量在此阶段被赋予默认值。</p></li>
<li><p>解析（Resolution）：将符号引用解析为直接引用。符号引用指向类、字段、方法的符号名称，而直接引用则是直接指向内存中的地址。</p></li>
<li><p>初始化（Initialization）：对类进行初始化，包括静态变量的赋值和静态代码块的执行。在初始化阶段，会按照程序员指定的顺序执行静态代码块和赋值操作。</p></li>
<li><p>使用（Usage）：使用已经加载和初始化的类，创建对象、调用方法等。</p></li>
<li><p>卸载（Unloading）：当一个类不再被使用，且满足一定条件时，它可以被卸载，释放内存空间。</p></li>
</ol>
<p>类加载机制是Java虚拟机的核心功能之一，它实现了动态加载和运行时多态性，使得Java程序具有高度的灵活性和可扩展性。通过类加载机制，Java程序可以根据需要加载和使用类，避免了静态编译时的依赖关系，并且支持动态添加、替换和卸载类的功能。</p>
</blockquote>
<ul>
<li><h3 id="hashmap数据结构">hashmap数据结构</h3></li>
</ul>
<blockquote>
<p>HashMap是一种常用的数据结构，它是基于哈希表实现的。下面是HashMap的数据结构：</p>
<ol type="1">
<li><p>数组（Array）：HashMap内部使用一个数组来存储数据。数组的每个元素称为桶（bucket），每个桶可以存储一个或多个键值对。</p></li>
<li><p>链表（LinkedList）或红黑树（Red-Black
Tree）：当多个键值对的哈希值相同时，它们会被存储在同一个桶中，并以链表或红黑树的形式进行存储。</p></li>
<li><p>键值对（Entry）：HashMap的每个元素都是一个键值对对象，包含一个键（Key）和一个值（Value）。</p></li>
<li><p>哈希函数（Hash
Function）：用于将键映射到数组索引的函数。HashMap使用键的哈希值与数组长度进行取模运算，来确定键值对在数组中的位置。</p></li>
</ol>
<p>HashMap的原理是通过哈希函数计算键的哈希值，然后将键值对存储在对应的桶中。当需要进行插入、查找或删除操作时，HashMap会根据键的哈希值定位到对应的桶，然后在桶中遍历链表或红黑树，找到目标键值对。</p>
<p>在JDK
8及之前的版本中，HashMap使用数组+链表的方式来解决哈希冲突。而在JDK
8及之后的版本中，当链表长度达到一定阈值时，会将链表转换为红黑树，以提高查找效率。</p>
<p>通过合理选择哈希函数和解决哈希冲突的方式，HashMap能够实现高效的键值对存取操作，并且具有较好的查找性能。</p>
</blockquote>
<ul>
<li><h3 id="hashmap是线程安全的吗">hashmap是线程安全的吗</h3></li>
</ul>
<blockquote>
<p>HashMap是非线程安全的。在多线程环境下，如果多个线程同时对HashMap进行读写操作，可能会导致数据不一致或出现并发冲突的问题。</p>
<p>如果需要在多线程环境下使用哈希表，可以考虑使用线程安全的ConcurrentHashMap。ConcurrentHashMap是Java提供的并发安全的哈希表实现，它使用了分段锁的机制，可以支持高效的并发读写操作。</p>
<p>另外，如果只是需要在单线程中使用哈希表，可以通过Collections工具类提供的方法，将HashMap转换为线程安全的版本，如使用<code>Collections.synchronizedMap()</code>方法包装HashMap，得到一个线程安全的Map对象。</p>
<p>总结来说，HashMap本身是非线程安全的，如果需要在线程环境下使用哈希表，应选择线程安全的ConcurrentHashMap或进行适当的同步处理。</p>
</blockquote>
<ul>
<li><h3 id="concurrenthashmap怎么实现">concurrentHashmap怎么实现</h3></li>
</ul>
<blockquote>
<p>ConcurrentHashMap是Java中并发安全的哈希表实现，它是在多线程环境下高效地支持并发操作的数据结构。下面简要介绍ConcurrentHashMap的实现原理：</p>
<ol type="1">
<li><p>分段锁：ConcurrentHashMap将内部的数据结构分成多个段（Segment），每个段维护一个子哈希表。每个段都拥有自己的锁，不同的线程可以同时访问不同的段，从而实现了并发读写操作。</p></li>
<li><p>Hash定位：ConcurrentHashMap使用哈希算法定位到具体的段，然后在该段内进行操作。通过将数据分散到不同的段中，减少了线程竞争的概率，提高了并发性能。</p></li>
<li><p>Segment内部结构：每个Segment内部使用类似HashMap的数据结构，包含了数组和链表（或红黑树）。每个节点包含了键值对的信息，相同哈希值的键值对会存储在同一个链表（或红黑树）中。</p></li>
<li><p>并发操作：对于并发的写操作，只需要锁定对应的段，而不是整个ConcurrentHashMap。这样可以避免对整个数据结构的串行访问。而对于并发的读操作，由于每个段都是独立的，线程之间可以同时进行读取操作。</p></li>
<li><p>扩容：当ConcurrentHashMap的负载因子达到一定阈值时，会触发扩容操作。在扩容时，会对每个段进行独立的扩容操作，而不会影响其他段的读写操作。扩容过程中，会将原来段中的节点重新分配到新的段中。</p></li>
</ol>
<p>通过上述的实现机制，ConcurrentHashMap实现了高效的并发读写操作。相比于传统的HashMap，在多线程环境下可以提供更好的性能和线程安全性。它适用于需要在多线程环境下进行高效并发访问的场景。</p>
</blockquote>
<ul>
<li><h3 id="gc流程">gc流程</h3></li>
</ul>
<blockquote>
<p>垃圾回收（Garbage
Collection，GC）是Java虚拟机（JVM）自动管理内存的一项重要功能。下面是简要的垃圾回收流程：</p>
<ol type="1">
<li><p>标记阶段（Marking）：从根对象（如栈中的引用、静态变量等）出发，通过可达性分析算法标记出所有活动对象（即不可回收的对象），将其标记为“存活”。</p></li>
<li><p>清除阶段（Sweeping）：在标记完成后，对堆中的未标记对象进行清除，释放占用的内存空间。被标记为“死亡”的对象将被回收。</p></li>
<li><p>压缩阶段（Compacting）：执行垃圾回收后，堆中会出现内存碎片的问题。在压缩阶段，将存活对象往一端移动，以便释放出连续的内存空间。</p></li>
<li><p>可选步骤：还有一些可选的垃圾回收步骤，如分代回收、并发标记等。分代回收是根据对象的存活时间将堆空间分为不同的代（如年轻代、老年代），对不同代使用不同的垃圾回收算法。并发标记是指在垃圾回收过程中，应用程序和垃圾回收器可以并发执行，减少垃圾回收对应用程序的影响。</p></li>
</ol>
<p>垃圾回收的具体实现和算法有多种，如标记-清除算法、复制算法、标记-整理算法等。不同的垃圾回收器使用不同的算法和策略，以达到平衡内存回收效率和应用程序性能的目标。</p>
<p>需要注意的是，垃圾回收过程是由JVM自动触发和执行的，开发者无需显式调用垃圾回收操作。然而，可以通过System.gc()方法建议JVM执行垃圾回收，但具体是否执行以及执行的时机仍由JVM决定。</p>
<p>垃圾回收是Java语言的一大特点，它使得开发者无需手动管理内存，提高了开发效率和应用程序的可靠性。但在某些情况下，垃圾回收也可能会对应用程序的性能产生一定的影响，因此需要合理地进行内存管理和优化。</p>
</blockquote>
<ul>
<li><h3 id="新建string类可以实现吗">新建string类可以实现吗</h3></li>
</ul>
<blockquote>
<p>在Java中，我们无法创建新的String类，因为String类是Java的内置类，并且是一个最终类（final
class），不能被继承。</p>
<p>String类是Java中非常重要的一个类，用于表示字符串对象。它具有不可变性（immutable），即一旦创建了String对象，就无法修改其内容。这是通过将String类中的字符数组声明为私有（private）和final来实现的。这种设计使得String对象在多线程环境下是线程安全的。</p>
<p>虽然我们无法创建新的String类，但可以通过String类提供的构造方法或操作符创建String对象。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);  <span class="comment">// 使用构造方法创建String对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;  <span class="comment">// 使用操作符创建String对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str1 + <span class="string">&quot; &quot;</span> + str2;  <span class="comment">// 使用操作符连接多个String对象</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，虽然String对象本身是不可变的，但我们可以通过字符串拼接、替换等操作来创建新的String对象。这些操作实际上是创建了新的String对象，并将原始String对象保持不变。</p>
<p>总结来说，我们无法创建新的String类，但可以通过String类提供的构造方法和操作符创建String对象，并通过操作符连接、替换等操作来创建新的String对象。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">早起星人</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/06/19/Java/">http://example.com/2023/06/19/Java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95/">后端开发面试</a></div><div class="post_share"><div class="social-share" data-image="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.png" target="_blank"><img class="post-qr-code-img" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.png" target="_blank"><img class="post-qr-code-img" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/19/SpringFrame/" title="Spring Boot"><img class="cover" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/spring-boot.jpg" onerror="onerror=null;src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Spring Boot</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/17/MySQL/" title="MySQL知识点"><img class="cover" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/数据库.jpg" onerror="onerror=null;src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">MySQL知识点</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/06/17/MySQL/" title="MySQL知识点"><img class="cover" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/数据库.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-17</div><div class="title">MySQL知识点</div></div></a></div><div><a href="/2023/06/19/SpringFrame/" title="Spring Boot"><img class="cover" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/spring-boot.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-19</div><div class="title">Spring Boot</div></div></a></div><div><a href="/2023/06/17/Redis/" title="Redis知识点"><img class="cover" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/redis-cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-17</div><div class="title">Redis知识点</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230511141236.png" onerror="this.onerror=null;this.src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">早起星人</div><div class="author-info__description">true</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/oneDuter"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my study Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E7%9A%84%E7%BB%93%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86jdk1.8%E4%BB%A5%E5%89%8D%E5%92%8C%E4%BB%A5%E5%90%8E"><span class="toc-number">1.</span> <span class="toc-text">Hashmap的结构及原理(JDK1.8以前和以后)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E4%B8%80%E8%BE%B9%E6%89%A9%E5%AE%B9%E4%B8%80%E8%BE%B9add%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.</span> <span class="toc-text">Hashmap一边扩容一边add会发生什么样的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E7%B4%A2%E5%BC%95-b%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-number">3.</span> <span class="toc-text">hash索引 B+树索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">4.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronize%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">Synchronize和Lock的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">6.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">7.</span> <span class="toc-text">检查时异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">9.</span> <span class="toc-text">泛型通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runnable%E5%92%8Ccallable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">runnable和callable的区别(!)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">11.</span> <span class="toc-text">常用的垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">12.</span> <span class="toc-text">垃圾回收器的组合使用(!)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm%E7%9A%84%E8%BF%90%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">13.</span> <span class="toc-text">JVM的运行数据区的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E7%9A%84"><span class="toc-number">14.</span> <span class="toc-text">线程间的信息如何传递的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">15.</span> <span class="toc-text">线程安全的集合类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">16.</span> <span class="toc-text">有哪些拒绝策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E8%BF%9B%E8%A1%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E5%8F%96%E5%BE%97%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%80%BC"><span class="toc-number">17.</span> <span class="toc-text">10个线程并发进行怎么保证安全，主线程怎么取得每个线程的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">18.</span> <span class="toc-text">jvm内存结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">19.</span> <span class="toc-text">类加载机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">20.</span> <span class="toc-text">hashmap数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="toc-number">21.</span> <span class="toc-text">hashmap是线程安全的吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrenthashmap%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">22.</span> <span class="toc-text">concurrentHashmap怎么实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc%E6%B5%81%E7%A8%8B"><span class="toc-number">23.</span> <span class="toc-text">gc流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BAstring%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%90%97"><span class="toc-number">24.</span> <span class="toc-text">新建string类可以实现吗</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/13/MyBatisPlus/" title="MyBatisPlus"><img src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/Mybatis-plus.png" onerror="this.onerror=null;this.src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/404.jpg'" alt="MyBatisPlus"/></a><div class="content"><a class="title" href="/2023/07/13/MyBatisPlus/" title="MyBatisPlus">MyBatisPlus</a><time datetime="2023-07-12T16:00:00.000Z" title="Created 2023-07-13 00:00:00">2023-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/13/Maven%E9%AB%98%E7%BA%A7/" title="Maven高级"><img src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/数据库.jpg" onerror="this.onerror=null;this.src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/404.jpg'" alt="Maven高级"/></a><div class="content"><a class="title" href="/2023/07/13/Maven%E9%AB%98%E7%BA%A7/" title="Maven高级">Maven高级</a><time datetime="2023-07-12T16:00:00.000Z" title="Created 2023-07-13 00:00:00">2023-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/13/SpringMVC_day01/" title="SpringMVC_one"><img src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/SpringMVC.png" onerror="this.onerror=null;this.src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/404.jpg'" alt="SpringMVC_one"/></a><div class="content"><a class="title" href="/2023/07/13/SpringMVC_day01/" title="SpringMVC_one">SpringMVC_one</a><time datetime="2023-07-12T16:00:00.000Z" title="Created 2023-07-13 00:00:00">2023-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/13/SpringMVC_day02/" title="SpringMVC_two"><img src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/SpringMVC.png" onerror="this.onerror=null;this.src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/404.jpg'" alt="SpringMVC_two"/></a><div class="content"><a class="title" href="/2023/07/13/SpringMVC_day02/" title="SpringMVC_two">SpringMVC_two</a><time datetime="2023-07-12T16:00:00.000Z" title="Created 2023-07-13 00:00:00">2023-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/13/Spring_day01/" title="Spring_one"><img src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/Spring.png" onerror="this.onerror=null;this.src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/404.jpg'" alt="Spring_one"/></a><div class="content"><a class="title" href="/2023/07/13/Spring_day01/" title="Spring_one">Spring_one</a><time datetime="2023-07-12T16:00:00.000Z" title="Created 2023-07-13 00:00:00">2023-07-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 早起星人</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>