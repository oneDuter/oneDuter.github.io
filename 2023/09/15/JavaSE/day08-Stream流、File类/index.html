<!DOCTYPE html><html lang="zh_CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Stream流、File、IO类 | 早起星人</title><meta name="author" content="早起星人"><meta name="copyright" content="早起星人"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java知识点总结">
<meta property="og:type" content="article">
<meta property="og:title" content="Stream流、File、IO类">
<meta property="og:url" content="http://example.com/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/index.html">
<meta property="og:site_name" content="早起星人">
<meta property="og:description" content="Java知识点总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png">
<meta property="article:published_time" content="2023-09-14T16:00:00.000Z">
<meta property="article:modified_time" content="2023-11-27T09:32:33.722Z">
<meta property="article:author" content="早起星人">
<meta property="article:tag" content="JavaSE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png"><link rel="shortcut icon" href="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/%E7%BD%91%E7%AB%99%E5%9B%BE%E6%A0%87.png"><link rel="canonical" href="http://example.com/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Stream流、File、IO类',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-27 17:32:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230511141236.png" onerror="onerror=null;src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/top_image/picture/java-top.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="早起星人"><span class="site-name">早起星人</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Stream流、File、IO类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-09-14T16:00:00.000Z" title="Created 2023-09-15 00:00:00">2023-09-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-11-27T09:32:33.722Z" title="Updated 2023-11-27 17:32:33">2023-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaSE/">JavaSE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Stream流、File、IO类"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="day08-stream流file类">day08-Stream流、File类</h1>
<h2 id="一jdk8新特性stream流">一、JDK8新特性（Stream流）</h2>
<p>接下来我们学习一个全新的知识，叫做Stream流（也叫Stream
API）。它是从JDK8以后才有的一个新特性，是专业用于<mark>对集合或者数组进行便捷操作</mark>的。有多方便呢？我们用一个案例体验一下，然后再详细学习。</p>
<h3 id="stream流体验">1.1 Stream流体验</h3>
<p>案例需求：有一个<code>List</code>集合，元素有<code>"张三丰","张无忌","周芷若","赵敏","张强"</code>，找出姓张，且是3个字的名字，存入到一个新集合中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(names, <span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">System.out.println(names);</span><br></pre></td></tr></table></figure>
<ul>
<li>用传统方式来做，代码是这样的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出姓张，且是3个字的名字，存入到一个新集合中去。</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    <span class="keyword">if</span>(name.startsWith(<span class="string">&quot;张&quot;</span>) &amp;&amp; name.length() == <span class="number">3</span>)&#123;</span><br><span class="line">        list.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<ul>
<li>用Stream流来做，代码是这样的（ps:
是不是像流水线一样，一句话就写完了）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list2 = names.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(a -&gt; a.length()==<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure>
<p>先不用知道这里面每一句话是什么意思，具体每一句话的含义，待会再一步步学习。现在只是体验一下。</p>
<p>学习Stream流我们接下来，会按照下面的步骤来学习。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667649164429.png"></p>
<h3 id="stream流的创建">1.2 Stream流的创建</h3>
<p>好，接下来我们正式来学习Stream流。先来学习如何创建Stream流、或者叫获取Stream流。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667649331568.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主要掌握下面四点：</span><br><span class="line">	<span class="number">1</span>、如何获取List集合的Stream流？</span><br><span class="line">	<span class="number">2</span>、如何获取Set集合的Stream流？</span><br><span class="line">	<span class="number">3</span>、如何获取Map集合的Stream流？</span><br><span class="line">	<span class="number">4</span>、如何获取数组的Stream流？</span><br></pre></td></tr></table></figure>
<p>直接上代码演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Stream流的创建。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、如何获取List集合的Stream流？</span></span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(names, <span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream = names.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、如何获取Set集合的Stream流？</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(set, <span class="string">&quot;刘德华&quot;</span>,<span class="string">&quot;张曼玉&quot;</span>,<span class="string">&quot;蜘蛛精&quot;</span>,<span class="string">&quot;马德&quot;</span>,<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; stream1 = set.stream();</span><br><span class="line">        stream1.filter(s -&gt; s.contains(<span class="string">&quot;德&quot;</span>)).forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、如何获取Map集合的Stream流？</span></span><br><span class="line">        Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">172.3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">168.3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">166.3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;卡尔扎巴&quot;</span>, <span class="number">168.3</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        Stream&lt;String&gt; ks = keys.stream();</span><br><span class="line"></span><br><span class="line">        Collection&lt;Double&gt; values = map.values();</span><br><span class="line">        Stream&lt;Double&gt; vs = values.stream();</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, Double&gt;&gt; kvs = entries.stream();</span><br><span class="line">        kvs.filter(e -&gt; e.getKey().contains(<span class="string">&quot;巴&quot;</span>))</span><br><span class="line">                .forEach(e -&gt; System.out.println(e.getKey()+ <span class="string">&quot;--&gt;&quot;</span> + e.getValue()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、如何获取数组的Stream流？</span></span><br><span class="line">        String[] names2 = &#123;<span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;东方不败&quot;</span>, <span class="string">&quot;唐大山&quot;</span>, <span class="string">&quot;独孤求败&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; s1 = Arrays.stream(names2);</span><br><span class="line">        Stream&lt;String&gt; s2 = Stream.of(names2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="stream流中间方法">1.3 Stream流中间方法</h3>
<p>在上一节，我们学习了创建Stream流的方法。接下来我们再来学习，Stream流中间操作的方法。</p>
<p><strong>中间方法指的是：调用完方法之后其结果是一个新的Stream流，于是可以继续调用方法，这样一来就可以支持链式编程</strong>（或者叫流式编程）。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667649379223.png"></p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667649509262.png"></p>
<p>话不多说，直接上代码演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握Stream流提供的常见中间方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; scores = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(scores, <span class="number">88.5</span>, <span class="number">100.0</span>, <span class="number">60.0</span>, <span class="number">99.0</span>, <span class="number">9.5</span>, <span class="number">99.6</span>, <span class="number">25.0</span>);</span><br><span class="line">        <span class="comment">// 需求1：找出成绩大于等于60分的数据，并升序后，再输出。</span></span><br><span class="line">        scores.stream().filter(s -&gt; s &gt;= <span class="number">60</span>).sorted().forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>, <span class="number">23</span>, <span class="number">167.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;白晶晶&quot;</span>, <span class="number">25</span>, <span class="number">169.0</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">35</span>, <span class="number">183.3</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛夫人&quot;</span>, <span class="number">34</span>, <span class="number">168.5</span>);</span><br><span class="line">        Collections.addAll(students, s1, s2, s3, s4, s5, s6);</span><br><span class="line">        <span class="comment">// 需求2：找出年龄大于等于23,且年龄小于等于30岁的学生，并按照年龄降序输出.</span></span><br><span class="line">        students.stream().filter(s -&gt; s.getAge() &gt;= <span class="number">23</span> &amp;&amp; s.getAge() &lt;= <span class="number">30</span>)</span><br><span class="line">                .sorted((o1, o2) -&gt; o2.getAge() - o1.getAge())</span><br><span class="line">                .forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求3：取出身高最高的前3名学生，并输出。</span></span><br><span class="line">        students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight()))</span><br><span class="line">                .limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求4：取出身高倒数的2名学生，并输出。   s1 s2 s3 s4 s5 s6</span></span><br><span class="line">        students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight()))</span><br><span class="line">                .skip(students.size() - <span class="number">2</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求5：找出身高超过168的学生叫什么名字，要求去除重复的名字，再输出。</span></span><br><span class="line">        students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>).map(Student::getName)</span><br><span class="line">               .distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// distinct去重复，自定义类型的对象（希望内容一样就认为重复，重写hashCode,equals）</span></span><br><span class="line">        students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>)</span><br><span class="line">                .distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; st1 = Stream.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; st2 = Stream.of(<span class="string">&quot;张三2&quot;</span>, <span class="string">&quot;李四2&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; allSt = Stream.concat(st1, st2);</span><br><span class="line">        allSt.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stream流终结方法">1.4 Stream流终结方法</h3>
<p>最后，我们再学习Stream流的终结方法。这些方法的特点是，调用完方法之后，其结果就不再是Stream流了，所以不支持链式编程。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667649788535.png"></p>
<p>我列举了下面的几个终结方法，接下来用几个案例来一个一个给同学们演示。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667649867150.png"></p>
<p>话不多说，直接上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：Stream流的终结方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;蜘蛛精&quot;</span>, <span class="number">26</span>, <span class="number">172.5</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;紫霞&quot;</span>, <span class="number">23</span>, <span class="number">167.6</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;白晶晶&quot;</span>, <span class="number">25</span>, <span class="number">169.0</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛魔王&quot;</span>, <span class="number">35</span>, <span class="number">183.3</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;牛夫人&quot;</span>, <span class="number">34</span>, <span class="number">168.5</span>);</span><br><span class="line">        Collections.addAll(students, s1, s2, s3, s4, s5, s6);</span><br><span class="line">        <span class="comment">// 需求1：请计算出身高超过168的学生有几人。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>).count();</span><br><span class="line">        System.out.println(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求2：请找出身高最高的学生对象，并输出。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> students.stream().max((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).get();</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求3：请找出身高最矮的学生对象，并输出。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">ss</span> <span class="operator">=</span> students.stream().min((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).get();</span><br><span class="line">        System.out.println(ss);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求4：请找出身高超过170的学生对象，并放到一个新集合中去返回。</span></span><br><span class="line">        <span class="comment">// 流只能收集一次。</span></span><br><span class="line">        List&lt;Student&gt; students1 = students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(students1);</span><br><span class="line"></span><br><span class="line">        Set&lt;Student&gt; students2 = students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>).collect(Collectors.toSet());</span><br><span class="line">        System.out.println(students2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求5：请找出身高超过170的学生对象，并把学生对象的名字和身高，存入到一个Map集合返回。</span></span><br><span class="line">        Map&lt;String, Double&gt; map =</span><br><span class="line">                students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>)</span><br><span class="line">                        .distinct().collect(Collectors.toMap(a -&gt; a.getName(), a -&gt; a.getHeight()));</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Object[] arr = students.stream().filter(a -&gt; a.getHeight() &gt; 170).toArray();</span></span><br><span class="line">        Student[] arr = students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>).toArray(len -&gt; <span class="keyword">new</span> <span class="title class_">Student</span>[len]);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，关于Stream流的操常见操作我们就已经学习完了。当然Stream流还有一些其他的方法，同学们遇到了也可以自己再研究一下。</p>
<h2 id="二file类">二、File类</h2>
<p>接下来，我们要学习的知识是一个File类。但是在讲这个知识点之前，我想先和同学们聊点别的，聊完之后再回过来学习File你会更容易理解一些。</p>
<ul>
<li><p>先问大家一个问题，目前你写代码时存储数据，可以用哪些方案?</p>
<p>答案如下图所示：可以是变量、可以是数组、可以是对象、可以是集合，但是这些数据都是存储在内存中的，只要程序执行结束，或者断点了，数据就消失了。不能永久存储。</p></li>
</ul>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667650170239.png"></p>
<ul>
<li><p>有些数据要长久保存，该怎么办呢？</p>
<p>答案如下图所示：可以将数据以文件的形式存在硬盘里，即使程序结束了，断点了只要硬盘没坏，数据就永久存在。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667650277680.png"></p></li>
</ul>
<p><strong>而现在要学习的File类，它的就用来表示当前系统下的文件（也可以是文件夹）</strong>，通过File类提供的方法可以获取文件大小、判断文件是否存在、创建文件、创建文件夹等。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667650503532.png"></p>
<p><strong>但是需要我们注意：</strong>File对象只能对文件进行操作，不能操作文件中的内容。</p>
<h3 id="file对象的创建">2.1 File对象的创建</h3>
<p>学习File类和其他类一样，第一步是创建File类的对象。
想要创建对象，我们得看File类有哪些构造方法。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667651303731.png"></p>
<p>下面我们演示一下，File类创建对象的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求我们注意的是：路径中<span class="string">&quot;\&quot;要写成&quot;</span>\\<span class="string">&quot;， 路径中&quot;</span>/<span class="string">&quot;可以直接用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握File创建对象，代表具体文件的方案。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个File对象，指代某个具体的文件。</span></span><br><span class="line">        <span class="comment">// 路径分隔符</span></span><br><span class="line">        <span class="comment">// File f1 = new File(&quot;D:/resource/ab.txt&quot;);</span></span><br><span class="line">        <span class="comment">// File f1 = new File(&quot;D:\\resource\\ab.txt&quot;);</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span> + File.separator +<span class="string">&quot;resource&quot;</span> + File.separator + <span class="string">&quot;ab.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.length()); <span class="comment">// 文件大小</span></span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource&quot;</span>);</span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：File对象可以指代一个不存在的文件路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/aaaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(f3.length());</span><br><span class="line">        System.out.println(f3.exists()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我现在要定位的文件是在模块中，应该怎么定位呢？</span></span><br><span class="line">        <span class="comment">// 绝对路径：带盘符的</span></span><br><span class="line">        <span class="comment">// File f4 = new File(&quot;D:\\code\\javasepromax\\file-io-app\\src\\itheima.txt&quot;);</span></span><br><span class="line">        <span class="comment">// 相对路径（重点）：不带盘符，默认是直接去工程下寻找文件的。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\itheima.txt&quot;</span>);</span><br><span class="line">        System.out.println(f4.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="file判断和获取方法">2.2 File判断和获取方法</h3>
<p>各位同学，刚才我们创建File对象的时候，会传递一个文件路径过来。但是File对象封装的路径是存在还是不存在，是文件还是文件夹其实是不清楚的。好在File类提供了方法可以帮我们做判断。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667659321570.png"></p>
<p>话不多少，直接上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     目标：掌握File提供的判断文件类型、获取文件信息功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 1.创建文件对象，指代某个文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/ab.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//File f1 = new File(&quot;D:/resource/&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、public boolean exists()：判断当前文件对象，对应的文件路径是否存在，存在返回true.</span></span><br><span class="line">        System.out.println(f1.exists());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、public boolean isFile() : 判断当前文件对象指代的是否是文件，是文件返回true，反之。</span></span><br><span class="line">        System.out.println(f1.isFile());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、public boolean isDirectory()  : 判断当前文件对象指代的是否是文件夹，是文件夹返回true，反之。</span></span><br><span class="line">        System.out.println(f1.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了判断功能还有一些获取功能，看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/ab.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.public String getName()：获取文件的名称（包含后缀）</span></span><br><span class="line">System.out.println(f1.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.public long length()：获取文件的大小，返回字节个数</span></span><br><span class="line">System.out.println(f1.length());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.public long lastModified()：获取文件的最后修改时间。</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> f1.lastModified();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(sdf.format(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.public String getPath()：获取创建文件对象时，使用的路径</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resource\\ab.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\itheima.txt&quot;</span>);</span><br><span class="line">System.out.println(f2.getPath());</span><br><span class="line">System.out.println(f3.getPath());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.public String getAbsolutePath()：获取绝对路径</span></span><br><span class="line">System.out.println(f2.getAbsolutePath());</span><br><span class="line">System.out.println(f3.getAbsolutePath());</span><br></pre></td></tr></table></figure>
<h3 id="创建和删除方法">2.3 创建和删除方法</h3>
<p>刚才有同学问老师，我们不能不用Java代码创建一个文件或者文件夹呀？答案是有的，不光可以创建还可以删除。</p>
<p>File类提供了创建和删除文件的方法，话不多少，看代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握File创建和删除文件相关的方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、public boolean createNewFile()：创建一个新文件（文件内容为空），创建成功返回true,反之。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/itheima2.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.createNewFile());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、public boolean mkdir()：用于创建文件夹，注意：只能创建一级文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/aaa&quot;</span>);</span><br><span class="line">        System.out.println(f2.mkdir());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、public boolean mkdirs()：用于创建文件夹，注意：可以创建多级文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/bbb/ccc/ddd/eee/fff/ggg&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdirs());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、public boolean delete()：删除文件，或者空文件，注意：不能删除非空文件夹。</span></span><br><span class="line">        System.out.println(f1.delete());</span><br><span class="line">        System.out.println(f2.delete());</span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource&quot;</span>);</span><br><span class="line">        System.out.println(f4.delete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>mkdir(): 只能创建单级文件夹、</span><br><span class="line"><span class="number">2.</span>mkdirs(): 才能创建多级文件夹</span><br><span class="line"><span class="number">3.</span>delete(): 文件可以直接删除，但是文件夹只能删除空的文件夹，文件夹有内容删除不了。</span><br></pre></td></tr></table></figure>
<h3 id="遍历文件夹方法">2.4 遍历文件夹方法</h3>
<p>有人说，想获取到一个文件夹中的内容，有没有方法呀？也是有的，下面我们就学习两个这样的方法。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667659732559.png"></p>
<p>话不多少上代码，演示一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握File提供的遍历文件夹的方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、public String[] list()：获取当前目录下所有的&quot;一级文件名称&quot;到一个字符串数组中去返回。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\course\\待研发内容&quot;</span>);</span><br><span class="line">        String[] names = f1.list();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、public File[] listFiles():（重点）获取当前目录下所有的&quot;一级文件对象&quot;到一个文件对象数组中去返回（重点）</span></span><br><span class="line">        File[] files = f1.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/aaa&quot;</span>);</span><br><span class="line">        File[] files1 = f.listFiles();</span><br><span class="line">        System.out.println(Arrays.toString(files1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意几个问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>当主调是文件时，或者路径不存在时，返回<span class="literal">null</span></span><br><span class="line"><span class="number">2.</span>当主调是空文件夹时，返回一个长度为<span class="number">0</span>的数组</span><br><span class="line"><span class="number">3.</span>当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹路径放在File数组中，并把数组返回</span><br><span class="line"><span class="number">4.</span>当主调是一个文件夹，且里面有隐藏文件时，将里面所有文件和文件夹的路径放在FIle数组中，包含隐藏文件</span><br><span class="line"><span class="number">5.</span>当主调是一个文件夹，但是没有权限访问时，返回<span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>关于遍历文件夹的基本操作就学习完了。
但是有同学如果想要获取文件夹中子文件夹的内容，那目前还做不到。但是学习下面了下面的递归知识就，很容易做到了。</p>
<h2 id="三递归">三、递归</h2>
<p>各位同学，为了获取文件夹中子文件夹的内容，我们就需要学习递归这个知识点。但是递归是什么意思，我们需要单独讲一下。学习完递归是什么，以及递归的执行流程之后，我们再回过头来用递归来找文件夹中子文件夹的内容。</p>
<h3 id="递归算法引入">3.1 递归算法引入</h3>
<ul>
<li><p>什么是递归？</p>
<p>递归是一种算法，从形式上来说，方法调用自己的形式称之为递归。</p></li>
<li><p>递归的形式：有直接递归、间接递归，如下面的代码。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：认识一下递归的形式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接方法递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----test1---&quot;</span>);</span><br><span class="line">        test1(); <span class="comment">// 直接方法递归</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 间接方法递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---test2---&quot;</span>);</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        test2(); <span class="comment">// 间接递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果直接执行上面的代码，会进入死循环，最终导致栈内存溢出</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667660323234.png"></p>
<p>以上只是用代码演示了一下，递归的形式。在下一节，在通过一个案例来给同学们讲一讲递归的执行流程。</p>
<h3 id="递归算法的执行流程">3.2 递归算法的执行流程</h3>
<p>为了弄清楚递归的执行流程，接下来我们通过一个案例来学习一下。</p>
<p>案例需求：计算n的阶乘，比如5的阶乘 = 1 * 2 * 3 * 4 * 5 ； 6 的阶乘 =
1 * 2 * 3 * 4 * 5 * 6</p>
<p>分析需求用递归该怎么做</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">假设f(n)表示n的阶乘，那么我们可以推导出下面的式子</span><br><span class="line">	 f(<span class="number">5</span>) = <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+<span class="number">4</span>+<span class="number">5</span></span><br><span class="line">    f(<span class="number">5</span>) = f(<span class="number">4</span>)+<span class="number">5</span></span><br><span class="line">    f(<span class="number">4</span>) = f(<span class="number">3</span>)+<span class="number">4</span></span><br><span class="line">    f(<span class="number">3</span>) = f(<span class="number">2</span>)+<span class="number">3</span></span><br><span class="line">    f(<span class="number">2</span>) = f(<span class="number">1</span>)+<span class="number">2</span></span><br><span class="line">    f(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">总结规律：</span><br><span class="line">	除了f(<span class="number">1</span>) = <span class="number">1</span>; 出口</span><br><span class="line">	其他的f(n) = f(n-<span class="number">1</span>)+n</span><br></pre></td></tr></table></figure>
<p>我们可以把f(n)当做一个方法，那么方法的写法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握递归的应用，执行流程和算法思想。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5的阶乘是：&quot;</span> + f(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求n个数的阶乘</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">// 终结点</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f(n - <span class="number">1</span>) * n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码的执行流程，我们用内存图的形式来分析一下，该案例中递归调用的特点是：<strong>一层一层调用，再一层一层往回返。</strong></p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667661022346.png"></p>
<h3 id="递归文件搜索">3.3 递归文件搜索</h3>
<p>学习完递归算法执行流程后，最后我们回过头来。再来看一下，如果使用递归来遍历文件夹。</p>
<p>案例需求：在<code>D:\\</code>判断下搜索QQ.exe这个文件，然后直接输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先调用文件夹的listFiles方法，获取文件夹的一级内容，得到一个数组</span><br><span class="line"><span class="number">2.</span>然后再遍历数组，获取数组中的File对象</span><br><span class="line"><span class="number">3.</span>因为File对象可能是文件也可能是文件夹，所以接下来就需要判断</span><br><span class="line">	判断File对象如果是文件，就获取文件名，如果文件名是`QQ.exe`则打印，否则不打印</span><br><span class="line">	判断File对象如果是文件夹，就递归执行<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>步骤</span><br><span class="line">所以：把<span class="number">1</span>，<span class="number">2</span>,<span class="number">3</span>步骤写成方法，递归调用即可。</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件搜索的实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">          searchFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/&quot;</span>) , <span class="string">&quot;QQ.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去目录下搜索某个文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir  目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 要搜索的文件名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFile</span><span class="params">(File dir, String fileName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、把非法的情况都拦截住</span></span><br><span class="line">        <span class="keyword">if</span>(dir == <span class="literal">null</span> || !dir.exists() || dir.isFile())&#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 代表无法搜索</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、dir不是null,存在，一定是目录对象。</span></span><br><span class="line">        <span class="comment">// 获取当前目录下的全部一级文件对象。</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、判断当前目录下是否存在一级文件对象，以及是否可以拿到一级文件对象。</span></span><br><span class="line">        <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 4、遍历全部一级文件对象。</span></span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                <span class="comment">// 5、判断文件是否是文件,还是文件夹</span></span><br><span class="line">                <span class="keyword">if</span>(f.isFile())&#123;</span><br><span class="line">                    <span class="comment">// 是文件，判断这个文件名是否是我们要找的</span></span><br><span class="line">                    <span class="keyword">if</span>(f.getName().contains(fileName))&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;找到了：&quot;</span> + f.getAbsolutePath());</span><br><span class="line">                        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">                        runtime.exec(f.getAbsolutePath());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 是文件夹，继续重复这个过程（递归）</span></span><br><span class="line">                    searchFile(f, fileName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="day09-字符集io流一">day09-字符集、IO流（一）</h1>
<p>各位同学，前面我们已经学习了File类，通过File类的对象可以对文件进行操作，但是不能操作文件中的内容。要想操作文件中的内容，我们还得学习IO流。但是在正式学习IO流之前，我们还需要学习一个前置知识叫做字符集，只有我们把字符集搞明白了，再学习IO流才会更加丝滑。</p>
<h2 id="一字符集">一、字符集</h2>
<h3 id="字符集的来历">1.1 字符集的来历</h3>
<p>所以，接下来我们正式学习一下字符集。先来带着同学们，了解一下字符集的来历。</p>
<p>我们知道计算机是美国人发明的，由于计算机能够处理的数据只能是0和1组成的二进制数据，为了让计算机能够处理字符，于是美国人就把他们会用到的每一个字符进行了编码（<strong>所谓编码，就是为一个字符编一个二进制数据</strong>），如下图所示：</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667738471094.png"></p>
<p>美国人常用的字符有英文字母、标点符号、数字以及一些特殊字符，这些字符一共也不到128个，所以他们用1个字节来存储1字符就够了。
美国人把他们用到的字符和字符对应的编码总结成了一张码表，这张码表叫做ASCII码表（也叫ASCII字符集）。</p>
<p>其实计算机只在美国用是没有问题的，但是计算机慢慢的普及到全世界，当普及到中国的时候，在计算机中想要存储中文，那ASCII字符集就不够用了，因为中文太多了，随便数一数也有几万个字符。</p>
<p>于是中国人为了在计算机中存储中文，也编了一个中国人用的字符集叫做GBK字符集，这里面包含2万多个汉字字符，<strong>GBK中一个汉字采用两个字节来存储</strong>，为了能够显示英文字母，GBK字符集也兼容了ASCII字符集，<strong>在GBK字符集中一个字母还是采用一个字节来存储</strong>。</p>
<h3 id="汉字和字母的编码特点">1.2 汉字和字母的编码特点</h3>
<p>讲到这里，可能有同学有这么一个疑问：
如果一个文件中既有中文，也有英文，那计算机怎么知道哪几个字节表示一个汉字，哪几个字节表示一个字母呢？</p>
<p>其实这个问题问当想当有水平，接下来，就带着同学们了解一下，计算机是怎么识别中文和英文的。</p>
<p>比如：在文件中存储一个<code>我a你</code>，底层其实存储的是这样的二进制数据。</p>
<p><strong>需要我们注意汉字和字母的编码特点：</strong></p>
<ul>
<li><ol type="1">
<li>如果是存储字母，采用1个字节来存储，一共8位，其中第1位是0</li>
<li>如果是存储汉字，采用2个字节来存储，一共16位，其中第1位是1</li>
</ol></li>
</ul>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667739473545.png"></p>
<p><strong>当读取文件中的字符时，通过识别读取到的第1位是0还是1来判断是字母还是汉字</strong></p>
<ul>
<li>如果读取到第1位是0，就认为是一个字母，此时往后读1个字节。</li>
<li>如果读取到第1位是1，就认为是一个汉字，此时往后读2个字节。</li>
</ul>
<h3 id="unicode字符集">1.3 Unicode字符集</h3>
<p>同学们注意了，咱们国家可以用GBK字符集来表示中国人使用的文字，那世界上还有很多其他的国家，他们也有自己的文字，他们也想要自己国家的文字在计算机中处理，于是其他国家也在搞自己的字符集，就这样全世界搞了上百个字符集，而且各个国家的字符集互不兼容。
这样其实很不利于国际化的交流，可能一个文件在我们国家的电脑上打开好好的，但是在其他国家打开就是乱码了。</p>
<p>为了解决各个国家字符集互不兼容的问题，由国际化标准组织牵头，设计了一套全世界通用的字符集，叫做Unicode字符集。在Unicode字符集中包含了世界上所有国家的文字，一个字符采用4个自己才存储。</p>
<p>在Unicode字符集中，采用一个字符4个字节的编码方案，又造成另一个问题：如果是说英语的国家，他们只需要用到26大小写字母，加上一些标点符号就够了，本身一个字节就可以表示完，用4个字节就有点浪费。</p>
<p>于是又对Unicode字符集中的字符进行了重新编码，一共设计了三种编码方案。分别是UTF-32、UTF-16、UTF-8;
<strong>其中比较常用的编码方案是UTF-8</strong></p>
<p>下面我们详细介绍一下UTF-8这种编码方案的特点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>UTF-<span class="number">8</span>是一种可变长的编码方案，工分为<span class="number">4</span>个长度区</span><br><span class="line"><span class="number">2.</span>英文字母、数字占<span class="number">1</span>个字节兼容(ASCII编码)</span><br><span class="line"><span class="number">3.</span>汉字字符占<span class="number">3</span>个字节</span><br><span class="line"><span class="number">4.</span>极少数字符占<span class="number">4</span>个字节</span><br></pre></td></tr></table></figure>
<h3 id="字符集小结">1.4 字符集小结</h3>
<p>最后，我们将前面介绍过的字符集小结一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ASCII字符集：《美国信息交换标准代码》，包含英文字母、数字、标点符号、控制字符</span><br><span class="line">	特点：<span class="number">1</span>个字符占<span class="number">1</span>个字节</span><br><span class="line"></span><br><span class="line">GBK字符集：中国人自己的字符集，兼容ASCII字符集，还包含<span class="number">2</span>万多个汉字</span><br><span class="line">	特点：<span class="number">1</span>个字母占用<span class="number">1</span>个字节；<span class="number">1</span>个汉字占用<span class="number">2</span>个字节</span><br><span class="line"></span><br><span class="line">Unicode字符集：包含世界上所有国家的文字，有三种编码方案，最常用的是UTF-<span class="number">8</span></span><br><span class="line">    UTF-<span class="number">8</span>编码方案：英文字母、数字占<span class="number">1</span>个字节兼容(ASCII编码)、汉字字符占<span class="number">3</span>个字节</span><br></pre></td></tr></table></figure>
<h3 id="编码和解码">1.5 编码和解码</h3>
<p>搞清楚字符集的知识之后，我们接下来再带着同学们使用Java代码完成编码和解码的操作。</p>
<p>其实String类类中就提供了相应的方法，可以完成编码和解码的操作。</p>
<ul>
<li>编码：把字符串按照指定的字符集转换为字节数组</li>
<li>解码：把字节数组按照指定的字符集转换为字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握如何使用Java代码完成对字符的编码和解码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;a我b&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = data.getBytes(); <span class="comment">// 默认是按照平台字符集（UTF-8）进行编码的。</span></span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照指定字符集进行编码。</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = data.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bytes1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、解码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes); <span class="comment">// 按照平台默认编码（UTF-8）解码</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes1, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二io流字节流">二、IO流（字节流）</h2>
<h3 id="io流概述">2.1 IO流概述</h3>
<p>各位小伙伴，在前面我们已经学习过File类。但是我们知道File只能操作文件，但是不能操作文件中的内容。我们也学习了字符集，不同的字符集存字符数据的原理是不一样的。有了前面两个知识的基础，接下来我们再学习IO流，就可以对文件中的数据进行操作了。</p>
<p>IO流的作用：就是可以对文件或者网络中的数据进行读、写的操作。如下图所示</p>
<ul>
<li>把数据从磁盘、网络中读取到程序中来，用到的是输入流。</li>
<li>把程序中的数据写入磁盘、网络中，用到的是输出流。</li>
<li><strong>简单记：输入流（读数据）、输出流（写数据）</strong></li>
</ul>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667822945208.png"></p>
<p>IO流在Java中有很多种，不同的流来干不同的事情。Java把各种流用不同的类来表示，这些流的继承体系如下图所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IO流分为两大派系：</span><br><span class="line">	<span class="number">1.</span>字节流：字节流又分为字节输入流、字节输出流</span><br><span class="line">	<span class="number">2.</span>字符流：字符流由分为字符输入流、字符输出流</span><br></pre></td></tr></table></figure>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667823186345.png"></p>
<h3 id="fileinputstream读取一个字节">2.2
FileInputStream读取一个字节</h3>
<p>同学们，在上节课认识了什么是IO流，接下来我们学习字节流中的字节输入流，用InputStream来表示。但是InputStream是抽象类，我们用的是它的子类，叫FileInputStream。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667823371395.png"></p>
<p>需要用到的方法如下图所示：有构造方法、成员方法</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667823417184.png"></p>
<p>使用FileInputStream读取文件中的字节数据，步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：创建FileInputStream文件字节输入流管道，与源文件接通。</span><br><span class="line">第二步：调用read()方法开始读取文件的字节数据。</span><br><span class="line">第三步：调用close()方法释放资源</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件字节输入流，每次读取一个字节。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建文件字节输入流管道，与源文件接通。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((<span class="string">&quot;file-io-app\\src\\itheima01.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始读取文件的字节数据。</span></span><br><span class="line">        <span class="comment">// public int read():每次读取一个字节返回，如果没有数据了，返回-1.</span></span><br><span class="line">        <span class="type">int</span> b; <span class="comment">// 用于记住读取的字节。</span></span><br><span class="line">        <span class="keyword">while</span> ((b = is.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、流使用完毕之后，必须关闭！释放系统资源！</span></span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意一个问题：由于一个中文在UTF-8编码方案中是占3个字节，采用一次读取一个字节的方式，读一个字节就相当于读了1/3个汉字，此时将这个字节转换为字符，是会有乱码的。</p>
<h3 id="fileinputstream读取多个字节">2.3
FileInputStream读取多个字节</h3>
<p>各位同学，在上一节我们学习了FileInputStream调用read()方法，可以一次读取一个字节。但是这种读取方式效率太太太太慢了。
为了提高效率，我们可以使用另一个read(byte[]
bytes)的重载方法，可以一次读取多个字节，至于一次读多少个字节，就在于你传递的数组有多大。</p>
<p>使用FileInputStream一次读取多个字节的步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：创建FileInputStream文件字节输入流管道，与源文件接通。</span><br><span class="line">第二步：调用read(<span class="type">byte</span>[] bytes)方法开始读取文件的字节数据。</span><br><span class="line">第三步：调用close()方法释放资源</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握使用FileInputStream每次读取多个字节。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个字节输入流对象代表字节输入流管道与源文件接通。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima02.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始读取文件中的字节数据：每次读取多个字节。</span></span><br><span class="line">        <span class="comment">//  public int read(byte b[]) throws IOException</span></span><br><span class="line">        <span class="comment">//  每次读取多个字节到字节数组中去，返回读取的字节数量，读取完毕会返回-1.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、使用循环改造。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。  abc 66</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 注意：读取多少，倒出多少。</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len);</span><br><span class="line">            System.out.print(rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 性能得到了明显的提升！！</span></span><br><span class="line">        <span class="comment">// 这种方案也不能避免读取汉字输出乱码的问题！！</span></span><br><span class="line"></span><br><span class="line">        is.close(); <span class="comment">// 关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>需要我们注意的是：<strong>read(byte[]
bytes)它的返回值，表示当前这一次读取的字节个数。</strong></li>
</ul>
<p>假设有一个a.txt文件如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcde</span><br></pre></td></tr></table></figure>
<p>每次读取过程如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">也就是说，并不是每次读取的时候都把数组装满，比如数组是 <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];</span><br><span class="line">第一次调用read(bytes)读取了<span class="number">3</span>个字节(分别是<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>)，并且往数组中存，此时返回值就是<span class="number">3</span></span><br><span class="line">第二次调用read(bytes)读取了<span class="number">2</span>个字节(分别是<span class="number">99</span>,<span class="number">100</span>),并且往数组中存，此时返回值是<span class="number">2</span></span><br><span class="line">第三次调用read(bytes)文件中后面已经没有数据了，此时返回值为-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>还需要注意一个问题：采用一次读取多个字节的方式，也是可能有乱码的。因为也有可能读取到半个汉字的情况。</li>
</ul>
<h3 id="fileinputstream读取全部字节">2.4
FileInputStream读取全部字节</h3>
<p>同学们，前面我们到的读取方式，不管是一次读取一个字节，还是一次读取多个字节，都有可能有乱码。那么接下来我们介绍一种，不出现乱码的读取方式。</p>
<p>我们可以一次性读取文件中的全部字节，然后把全部字节转换为一个字符串，就不会有乱码了。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667830119965.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、一次性读取完文件的全部字节到一个字节数组中去。</span></span><br><span class="line"><span class="comment">// 创建一个字节输入流管道与源文件接通</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、准备一个字节数组，大小与文件的大小正好一样大。</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> f.length();</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) size];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(buffer);</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、关闭流</span></span><br><span class="line">is.close(); </span><br></pre></td></tr></table></figure>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667830186936.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、一次性读取完文件的全部字节到一个字节数组中去。</span></span><br><span class="line"><span class="comment">// 创建一个字节输入流管道与源文件接通</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、调用方法读取所有字节，返回一个存储所有字节的字节数组。</span></span><br><span class="line"><span class="type">byte</span>[] buffer = is.readAllBytes();</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、关闭流</span></span><br><span class="line">is.close(); </span><br></pre></td></tr></table></figure>
<p>最后，还是要注意一个问题：<strong>一次读取所有字节虽然可以解决乱码问题，但是文件不能过大，如果文件过大，可能导致内存溢出。</strong></p>
<h3 id="fileoutputstream写字节">2.5 FileOutputStream写字节</h3>
<p>各位同学，前面我们学习了使用FIleInputStream读取文件中的字节数据。然后有同学就迫不及待的想学习往文件中写入数据了。</p>
<p>往文件中写数据需要用到OutputStream下面的一个子类FileOutputStream。写输入的流程如下图所示</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667830581838.png"></p>
<p>使用FileOutputStream往文件中写数据的步骤如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：创建FileOutputStream文件字节输出流管道，与目标文件接通。</span><br><span class="line">第二步：调用wirte()方法往文件中写数据</span><br><span class="line">第三步：调用close()方法释放资源</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件字节输出流FileOutputStream的使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">        <span class="comment">// 覆盖管道：覆盖之前的数据</span></span><br><span class="line"><span class="comment">//        OutputStream os =</span></span><br><span class="line"><span class="comment">//                new FileOutputStream(&quot;file-io-app/src/itheima04out.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追加数据的管道</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/itheima04out.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始写字节数据出去了</span></span><br><span class="line">        os.write(<span class="number">97</span>); <span class="comment">// 97就是一个字节，代表a</span></span><br><span class="line">        os.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// &#x27;b&#x27;也是一个字节</span></span><br><span class="line">        <span class="comment">// os.write(&#x27;磊&#x27;); // [ooo] 默认只能写出去一个字节</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;我爱你中国abc&quot;</span>.getBytes();</span><br><span class="line">        os.write(bytes);</span><br><span class="line"></span><br><span class="line">        os.write(bytes, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 换行符</span></span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        os.close(); <span class="comment">// 关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字节流复制文件">2.6 字节流复制文件</h3>
<p>同学们，我们在前面已经把字节输入流和字节输出流都学习完了。现在我们就可以用这两种流配合起来使用，做一个文件复制的综合案例。</p>
<p>比如：我们要复制一张图片，从磁盘<code>D:/resource/meinv.png</code>的一个位置，复制到<code>C:/data/meinv.png</code>位置。</p>
<p>复制文件的思路如下图所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>需要创建一个FileInputStream流与源文件接通，创建FileOutputStream与目标文件接通</span><br><span class="line"><span class="number">2.</span>然后创建一个数组，使用FileInputStream每次读取一个字节数组的数据，存如数组中</span><br><span class="line"><span class="number">3.</span>然后再使用FileOutputStream把字节数组中的有效元素，写入到目标文件中</span><br></pre></td></tr></table></figure>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667830863144.png"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：使用字节流完成对文件的复制操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyTest5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 需求：复制照片。</span></span><br><span class="line">        <span class="comment">// 1、创建一个字节输入流管道与源文件接通</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/resource/meinv.png&quot;</span>);</span><br><span class="line">        <span class="comment">// 2、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:/data/meinv.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="number">10</span> / <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 3、创建一个字节数组，负责转移字节数据。</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 1KB.</span></span><br><span class="line">        <span class="comment">// 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。</span></span><br><span class="line">        <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;复制完成！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三io流资源释放">三、IO流资源释放</h2>
<p>各位同学，前面我们已经学习了字节流，也给同学们强调过，流使用完之后一定要释放资源。但是我们之前的代码并不是很专业。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667831281147.png"></p>
<p>我们现在知道这个问题了，那这个问题怎么解决呢？
在JDK7以前，和JDK7以后分别给出了不同的处理方案。</p>
<h3 id="jdk7以前的资源释放">3.1 JDK7以前的资源释放</h3>
<p>在JDK7版本以前，我们可以使用try...catch...finally语句来处理。格式如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//有可能产生异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类 e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//释放资源的代码</span></span><br><span class="line">    <span class="comment">//finally里面的代码有一个特点，不管异常是否发生，finally里面的代码都会执行。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改造上面的低吗：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="number">10</span> / <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 1、创建一个字节输入流管道与源文件接通</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 2、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03copy.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="number">10</span> / <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、创建一个字节数组，负责转移字节数据。</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 1KB.</span></span><br><span class="line">            <span class="comment">// 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。</span></span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成！！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源的操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(os != <span class="literal">null</span>) os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(is != <span class="literal">null</span>) is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码写到这里，有很多同学就已经看不下去了。是的，我也看不下去，本来几行代码就写完了的，加上try...catch...finally之后代码多了十几行，而且阅读性并不高。难受....</p>
<h3 id="jdk7以后的资源释放">3.2 JDK7以后的资源释放</h3>
<p>刚才很多同学已经发现了try...catch...finally处理异常，并释放资源代码比较繁琐。Java在JDK7版本为我们提供了一种简化的是否资源的操作，它会自动是否资源。代码写起来也想当简单。</p>
<p>格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(资源对象<span class="number">1</span>; 资源对象<span class="number">2</span>;)&#123;</span><br><span class="line">    使用资源的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类 e)&#123;</span><br><span class="line">    处理异常的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：注意到没有，这里没有释放资源的代码。它会自动是否资源</span></span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握释放资源的方式：try-with-resource</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    	<span class="keyword">try</span> (</span><br><span class="line">          <span class="comment">// 1、创建一个字节输入流管道与源文件接通</span></span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/resource/meinv.png&quot;</span>);</span><br><span class="line">          <span class="comment">// 2、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">          <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:/data/meinv.png&quot;</span>);</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">// 3、创建一个字节数组，负责转移字节数据。</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 1KB.</span></span><br><span class="line">            <span class="comment">// 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。</span></span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(conn);</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="day10-io流二">day10-IO流（二）</h1>
<h2 id="一字符流">一、字符流</h2>
<p>同学们，前面我们学习了字节流，使用字节流可以读取文件中的字节数据。但是如果文件中有中文，使用字节流来读取，就有可能读到半个汉字的情况，这样会导致乱码。虽然使用读取全部字节的方法不会出现乱码，但是如果文件过大又不太合适。</p>
<p>所以Java专门为我们提供了另外一种流，叫字符流，可以字符流是专门为读取文本数据而生的。</p>
<h3 id="filereader类">1.1 FileReader类</h3>
<p>先类学习字符流中的FileReader类，这是字符输入流，用来将文件中的字符数据读取到程序中来。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667914646397.png"></p>
<p>FileReader读取文件的步骤如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：创建FileReader对象与要读取的源文件接通</span><br><span class="line">第二步：调用read()方法读取文件中的字符</span><br><span class="line">第三步：调用close()方法关闭流</span><br></pre></td></tr></table></figure>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667914727332.png"></p>
<p>需要用到的方法：先通过构造器创建对象，再通过read方法读取数据（<strong>注意：两个read方法的返回值，含义不一样</strong>）</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667915012716.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件字符输入流。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个文件字符输入流管道与源文件接通</span></span><br><span class="line">                <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;io-app2\\src\\itheima01.txt&quot;</span>);</span><br><span class="line">                )&#123;</span><br><span class="line">            <span class="comment">// 2、一个字符一个字符的读（性能较差）</span></span><br><span class="line"><span class="comment">//            int c; // 记住每次读取的字符编号。</span></span><br><span class="line"><span class="comment">//            while ((c = fr.read()) != -1)&#123;</span></span><br><span class="line"><span class="comment">//                System.out.print((char) c);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">// 每次读取一个字符的形式，性能肯定是比较差的。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、每次读取多个字符。（性能是比较不错的！）</span></span><br><span class="line">            <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">3</span>];</span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字符。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = fr.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 读取多少倒出多少</span></span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="filewriter类">1.2 FileWriter类</h3>
<p>在上节课，我们学习了FileReader，它可以将文件中的字符数据读取到程序中来。接下来，我们就要学习FileWriter了，它可以将程序中的字符数据写入文件。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667915174777.png"></p>
<p>FileWriter往文件中写字符数据的步骤如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步：创建FileWirter对象与要读取的目标文件接通</span><br><span class="line">第二步：调用write(字符数据/字符数组/字符串)方法读取文件中的字符</span><br><span class="line">第三步：调用close()方法关闭流</span><br></pre></td></tr></table></figure>
<p>需要用到的方法如下：构造器是用来创建FileWriter对象的，有了对象才能调用write方法写数据到文件。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667915265102.png"></p>
<p>接下来，用代码演示一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：掌握文件字符输出流：写字符数据出去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriterTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 0、创建一个文件字符输出流管道与目标文件接通。</span></span><br><span class="line">                <span class="comment">// 覆盖管道</span></span><br><span class="line">                <span class="comment">// Writer fw = new FileWriter(&quot;io-app2/src/itheima02out.txt&quot;);</span></span><br><span class="line">                <span class="comment">// 追加数据的管道</span></span><br><span class="line">                <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/itheima02out.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                )&#123;</span><br><span class="line">            <span class="comment">// 1、public void write(int c):写一个字符出去</span></span><br><span class="line">            fw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            fw.write(<span class="number">97</span>);</span><br><span class="line">            <span class="comment">//fw.write(&#x27;磊&#x27;); // 写一个字符出去</span></span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、public void write(String c)写一个字符串出去</span></span><br><span class="line">            fw.write(<span class="string">&quot;我爱你中国abc&quot;</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、public void write(String c ,int pos ,int len):写字符串的一部分出去</span></span><br><span class="line">            fw.write(<span class="string">&quot;我爱你中国abc&quot;</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、public void write(char[] buffer):写一个字符数组出去</span></span><br><span class="line">            <span class="type">char</span>[] buffer = &#123;<span class="string">&#x27;黑&#x27;</span>, <span class="string">&#x27;马&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">            fw.write(buffer);</span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5、public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去</span></span><br><span class="line">            fw.write(buffer, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="filewriter写的注意事项">1.3 FileWriter写的注意事项</h3>
<p>各位同学，刚才我们已经学习了FileWriter字符输出流的基本使用。但是，这里有一个小问题需要和同学们说下一：<strong>FileWriter写完数据之后，必须刷新或者关闭，写出去的数据才能生效。</strong></p>
<p>比如：下面的代码只调用了写数据的方法，没有关流的方法。当你打开目标文件时，是看不到任何数据的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建FileWriter对象</span></span><br><span class="line"><span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/itheima03out.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.写字符数据出去</span></span><br><span class="line">fw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>而下面的代码，加上了flush()方法之后，数据就会立即到目标文件中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建FileWriter对象</span></span><br><span class="line"><span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/itheima03out.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.写字符数据出去</span></span><br><span class="line">fw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.刷新</span></span><br><span class="line">fw.flush(); </span><br></pre></td></tr></table></figure>
<p>下面的代码，调用了close()方法，数据也会立即到文件中去。因为close()方法在关闭流之前，会将内存中缓存的数据先刷新到文件，再关流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建FileWriter对象</span></span><br><span class="line"><span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/itheima03out.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.写字符数据出去</span></span><br><span class="line">fw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">fw.write(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.关闭流</span></span><br><span class="line">fw.close(); <span class="comment">//会先刷新，再关流</span></span><br></pre></td></tr></table></figure>
<p>但是需要注意的是，关闭流之后，就不能在对流进行操作了。否则会出异常</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667915749299.png"></p>
<h2 id="二缓冲流">二、缓冲流</h2>
<p>学习完字符流之后，接下来我们学习一下缓冲流。我们还是先来认识一下缓存流，再来说一下它的作用。缓冲流有四种，如下图所示</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667915902693.png"></p>
<p><strong>缓冲流的作用</strong>：可以对原始流进行包装，提高原始流读写数据的性能。</p>
<h3 id="缓冲字节流">2.1 缓冲字节流</h3>
<p>我们先来学习字节缓冲流是如何提高读写数据的性能的，原理如下图所示。是因为在缓冲流的底层自己封装了一个长度为8KB（8129byte）的字节数组，但是缓冲流不能单独使用，它需要依赖于原始流。</p>
<ul>
<li><strong>读数据时：</strong>它先用原始字节输入流一次性读取8KB的数据存入缓冲流内部的数组中（ps:
先一次多囤点货），再从8KB的字节数组中读取一个字节或者多个字节（把消耗屯的货）。</li>
</ul>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667916051946.png"></p>
<ul>
<li><strong>写数据时：</strong>
它是先把数据写到缓冲流内部的8BK的数组中（ps:
先攒一车货），等数组存满了，再通过原始的字节输出流，一次性写到目标文件中去（把囤好的货，一次性运走）。</li>
</ul>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667916766340.png"></p>
<p>在创建缓冲字节流对象时，需要封装一个原始流对象进来。构造方法如下</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667916924862.png"></p>
<p>如果我们用缓冲流复制文件，代码写法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;io-app2/src/itheima01.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 1、定义一个字节缓冲输入流包装原始的字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(is);</span><br><span class="line"></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/itheima01_bak.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 2、定义一个字节缓冲输出流包装原始的字节输出流</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(os);</span><br><span class="line">        )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符缓冲流">2.2 字符缓冲流</h3>
<p>接下来，我们学习另外两个缓冲流——字符缓冲流。它的原理和字节缓冲流是类似的，它底层也会有一个8KB的数组，但是这里是字符数组。字符缓冲流也不能单独使用，它需要依赖于原始字符流一起使用。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667918228776.png"></p>
<ul>
<li><strong>BufferedReader读数据时：</strong>它先原始字符输入流一次性读取8KB的数据存入缓冲流内部的数组中（ps:
先一次多囤点货），再从8KB的字符数组中读取一个字符或者多个字符（把消耗屯的货）。</li>
</ul>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667918633907.png"></p>
<p>创建BufferedReader对象需要用到BufferedReader的构造方法，内部需要封装一个原始的字符输入流，我们可以传入FileReader.</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667919020690.png"></p>
<p>而且BufferedReader还要特有的方法，一次可以读取文本文件中的一行</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667919061356.png"></p>
<p>使用BufferedReader读取数据的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">Reader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;io-app2\\src\\itheima04.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 创建一个字符缓冲输入流包装原始的字符输入流</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">        )&#123;</span><br><span class="line"><span class="comment">//            char[] buffer = new char[3];</span></span><br><span class="line"><span class="comment">//            int len;</span></span><br><span class="line"><span class="comment">//            while ((len = br.read(buffer)) != -1)&#123;</span></span><br><span class="line"><span class="comment">//                System.out.print(new String(buffer, 0, len));</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">//            System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">//            System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">//            System.out.println(br.readLine());</span></span><br><span class="line"></span><br><span class="line">            String line; <span class="comment">// 记住每次读取的一行数据</span></span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>BufferedWriter写数据时：</strong>
它是先把数据写到字符缓冲流内部的8BK的数组中（ps:
先攒一车货），等数组存满了，再通过原始的字符输出流，一次性写到目标文件中去（把囤好的货，一次性运走）。如下图所示</li>
</ul>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667918775445.png"></p>
<p>创建BufferedWriter对象时需要用到BufferedWriter的构造方法，而且内部需要封装一个原始的字符输出流，我们这里可以传递FileWriter。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667919195054.png"></p>
<p>而且BufferedWriter新增了一个功能，可以用来写一个换行符</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667919243053.png"></p>
<p>接下来，用代码演示一下，使用BufferedWriter往文件中写入字符数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriterTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">Writer</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;io-app2/src/itheima05out.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                <span class="comment">// 创建一个字符缓冲输出流管道包装原始的字符输出流</span></span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">        )&#123;</span><br><span class="line"></span><br><span class="line">            bw.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            bw.write(<span class="number">97</span>);</span><br><span class="line">            bw.write(<span class="string">&#x27;磊&#x27;</span>);</span><br><span class="line">            bw.newLine();</span><br><span class="line"></span><br><span class="line">            bw.write(<span class="string">&quot;我爱你中国abc&quot;</span>);</span><br><span class="line">            bw.newLine();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缓冲流性能分析">2.3 缓冲流性能分析</h3>
<p>我们说缓冲流内部多了一个数组，可以提高原始流的读写性能。讲到这一定有同学有这么一个疑问，它和我们使用原始流，自己加一个8BK数组不是一样的吗？
缓冲流就一定能提高性能吗？先告诉同学们答案，<strong>缓冲流不一定能提高性能</strong>。</p>
<blockquote>
<p>下面我们用一个比较大文件（889MB）复制，做性能测试，分别使用下面四种方式来完成文件复制，并记录文件复制的时间。</p>
</blockquote>
<p>① 使用低级流一个字节一个字节的复制</p>
<p>② 使用低级流按照字节数组的形式复制</p>
<p>③ 使用缓冲流一个字节一个字节的复制</p>
<p>④ 使用缓冲流按照字节数组的形式复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">低级流一个字节复制: 慢得简直让人无法忍受</span><br><span class="line">低级流按照字节数组复制(数组长度<span class="number">1024</span>): <span class="number">12.</span>117s</span><br><span class="line">缓冲流一个字节复制: <span class="number">11.</span>058s</span><br><span class="line">缓冲流按照字节数组复制(数组长度<span class="number">1024</span>): <span class="number">2.</span>163s</span><br><span class="line">【注意：这里的测试只能做一个参考，和电脑性能也有直接关系】</span><br></pre></td></tr></table></figure>
<p>经过上面的测试，我们可以得出一个结论：<strong>默认情况下，采用一次复制1024个字节，缓冲流完胜。</strong></p>
<blockquote>
<p>但是，缓冲流就一定性能高吗？我们采用一次复制8192个字节试试</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低级流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">2.</span>535s</span><br><span class="line">缓冲流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">2.</span>088s</span><br></pre></td></tr></table></figure>
<p>经过上面的测试，我们可以得出一个结论：<strong>一次读取8192个字节时，低级流和缓冲流性能相当。</strong>相差的那几毫秒可以忽略不计。</p>
<blockquote>
<p>继续把数组变大，看一看缓冲流就一定性能高吗？现在采用一次读取1024*32个字节数据试试</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低级流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">1.</span>128s</span><br><span class="line">缓冲流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">1.</span>133s</span><br></pre></td></tr></table></figure>
<p>经过上面的测试，我们可以得出一个结论：<strong>数组越大性能越高，低级流和缓冲流性能相当。</strong>相差的那几秒可以忽略不计。</p>
<blockquote>
<p>继续把数组变大，看一看缓冲流就一定性能高吗？现在采用一次读取1024*6个字节数据试试</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低级流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">1.</span>039s</span><br><span class="line">缓冲流按照字节数组复制(数组长度<span class="number">8192</span>): <span class="number">1.</span>151s</span><br></pre></td></tr></table></figure>
<p>此时你会发现，当数组大到一定程度，性能已经提高了多少了，甚至缓冲流的性能还没有低级流高。</p>
<p>最终总结一下：<strong>缓冲流的性能不一定比低级流高，其实低级流自己加一个数组，性能其实是不差。</strong>只不过缓冲流帮你加了一个相对而言大小比较合理的数组
。</p>
<h2 id="三转换流">三、转换流</h2>
<p>前面我们学习过FileReader读取文件中的字符，但是同学们注意了，FileReader默认只能读取UTF-8编码格式的文件。如果使用FileReader读取GBK格式的文件，可能存在乱码，因为FileReader它遇到汉字默认是按照3个字节来读取的，而GBK格式的文件一个汉字是占2个字节，这样就会导致乱码。</p>
<p>Java给我们提供了另外两种流InputStreamReader，OutputStreamWriter，这两个流我们把它叫做转换流。它们可以将字节流转换为字符流，并且可以指定编码方案。</p>
<h3 id="inputstreamreader类">3.1 InputStreamReader类</h3>
<p>接下来，我们先学习InputStreamReader类，你看这个类名就比较有意思，前面是InputStream表示字节输入流，后面是Reader表示字符输入流，合在一起意思就是表示可以把InputStream转换为Reader，最终InputStreamReader其实也是Reader的子类，所以也算是字符输入流。</p>
<p>InputStreamReader也是不能单独使用的，它内部需要封装一个InputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。</p>
<blockquote>
<p>需求：我们可以先准备一个GBK格式的文件，然后使用下面的代码进行读取，看是是否有乱码。</p>
</blockquote>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667922646132.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReaderTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、得到文件的原始字节流（GBK的字节流形式）</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;io-app2/src/itheima06.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 2、把原始的字节输入流按照指定的字符集编码转换成字符输入流</span></span><br><span class="line">                <span class="type">Reader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">                <span class="comment">// 3、把字符输入流包装成缓冲字符输入流</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">                )&#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完之后，你会发现没有乱码。</p>
<h3 id="outputstreamwriter类">3.2 OutputStreamWriter类</h3>
<p>接下来，我们先学习OutputStreamWriter类，你看这个类名也比较有意思，前面是OutputStream表示字节输出流，后面是Writer表示字符输出流，合在一起意思就是表示可以把OutputStream转换为Writer，最终OutputStreamWriter其实也是Writer的子类，所以也算是字符输出流。</p>
<p>OutputStreamReader也是不能单独使用的，它内部需要封装一个OutputStream的子类对象，再指定一个编码表，如果不指定编码表，默认会按照UTF-8形式进行转换。</p>
<blockquote>
<p>需求：我们可以先准备一个GBK格式的文件，使用下面代码往文件中写字符数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriterTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定写出去的字符编码。</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个文件字节输出流</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/itheima07out.txt&quot;</span>);</span><br><span class="line">                <span class="comment">// 2、把原始的字节输出流，按照指定的字符集编码转换成字符输出转换流。</span></span><br><span class="line">                <span class="type">Writer</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(os, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">                <span class="comment">// 3、把字符输出流包装成缓冲字符输出流</span></span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(osw);</span><br><span class="line">                )&#123;</span><br><span class="line">            bw.write(<span class="string">&quot;我是中国人abc&quot;</span>);</span><br><span class="line">            bw.write(<span class="string">&quot;我爱你中国123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四打印流">四、打印流</h2>
<p>接下来，我们学习打印流，其实打印流我们从开学第一天就一直再使用，只是没有学到你感受不到而已。打印流可以实现更加方便，更加高效的写数据的方式。</p>
<h3 id="打印流基本使用">4.1 打印流基本使用</h3>
<p>打印流，这里所说的打印其实就是写数据的意思，它和普通的write方法写数据还不太一样，一般会使用打印流特有的方法叫<code>print(数据)</code>或者<code>println(数据)</code>，它打印啥就输出啥。</p>
<p>打印流有两个，一个是字节打印流PrintStream，一个是字符打印流PrintWriter，如下图所示</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667923225787.png"></p>
<p><strong>PrintStream和PrintWriter的用法是一样的，所以这里就一块演示了。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个打印流管道</span></span><br><span class="line"><span class="comment">//                PrintStream ps =</span></span><br><span class="line"><span class="comment">//                        new PrintStream(&quot;io-app2/src/itheima08.txt&quot;, Charset.forName(&quot;GBK&quot;));</span></span><br><span class="line"><span class="comment">//                PrintStream ps =</span></span><br><span class="line"><span class="comment">//                        new PrintStream(&quot;io-app2/src/itheima08.txt&quot;);</span></span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">ps</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/itheima08.txt&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">                )&#123;</span><br><span class="line">                ps.print(<span class="number">97</span>);	<span class="comment">//文件中显示的就是:97</span></span><br><span class="line">                ps.print(<span class="string">&#x27;a&#x27;</span>); <span class="comment">//文件中显示的就是:a</span></span><br><span class="line">                ps.println(<span class="string">&quot;我爱你中国abc&quot;</span>);	<span class="comment">//文件中显示的就是:我爱你中国abc</span></span><br><span class="line">                ps.println(<span class="literal">true</span>);<span class="comment">//文件中显示的就是:true</span></span><br><span class="line">                ps.println(<span class="number">99.5</span>);<span class="comment">//文件中显示的就是99.5</span></span><br><span class="line"></span><br><span class="line">                ps.write(<span class="number">97</span>); <span class="comment">//文件中显示a，发现和前面println方法的区别了吗？</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重定向输出语句">4.2 重定向输出语句</h3>
<p>其实我们开学第一课，就给同学们讲过<code>System.out.println()</code>这句话表示打印输出，但是至于为什么能够输出，其实我们一直不清楚。</p>
<p>以前是因为知识储备还不够，无法解释，到现在就可以给同学们揭晓谜底了，因为System里面有一个静态变量叫out，out的数据类型就是PrintStream，它就是一个打印流，而且这个打印流的默认输出目的地是控制台，所以我们调用<code>System.out.pirnln()</code>就可以往控制台打印输出任意类型的数据，而且打印啥就输出啥。</p>
<p>而且System还提供了一个方法，可以修改底层的打印流，这样我们就可以重定向打印语句的输出目的地了。我们玩一下,
直接上代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老骥伏枥&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;志在千里&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> ( <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;io-app2/src/itheima09.txt&quot;</span>); )&#123;</span><br><span class="line">            <span class="comment">// 把系统默认的打印流对象改成自己设置的打印流</span></span><br><span class="line">            System.setOut(ps);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;烈士暮年&quot;</span>);	</span><br><span class="line">            System.out.println(<span class="string">&quot;壮心不已&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时打印语句，将往文件中打印数据，而不在控制台。</p>
<h2 id="五数据流">五、数据流</h2>
<p>同学们，接下我们再学习一种流，这种流在开发中偶尔也会用到。比如，我们想把数据和数据的类型一并写到文件中去，读取的时候也将数据和数据类型一并读出来。这就可以用到数据流，有两个DataInputStream和DataOutputStream.</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667924066920.png"></p>
<h3 id="dataoutputstream类">5.1 DataOutputStream类</h3>
<p>我们先学习DataOutputStream类，它也是一种包装流，创建DataOutputStream对象时，底层需要依赖于一个原始的OutputStream流对象。然后调用它的wirteXxx方法，写的是特定类型的数据。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667924147403.png"></p>
<p>代码如下：往文件中写整数、小数、布尔类型数据、字符串数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataOutputStreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 1、创建一个数据输出流包装低级的字节输出流</span></span><br><span class="line">                <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/itheima10out.txt&quot;</span>));</span><br><span class="line">                )&#123;</span><br><span class="line">            dos.writeInt(<span class="number">97</span>);</span><br><span class="line">            dos.writeDouble(<span class="number">99.5</span>);</span><br><span class="line">            dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">            dos.writeUTF(<span class="string">&quot;黑马程序员666！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="datainputstream类">5.2 DataInputStream类</h3>
<p>学习完DataOutputStream后，再学习DataIntputStream类，它也是一种包装流，创建DataInputStream对象时，底层需要依赖于一个原始的InputStream流对象。然后调用它的readXxx()方法就可以读取特定类型的数据。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667924375953.png"></p>
<p>代码如下：读取文件中特定类型的数据（整数、小数、字符串等）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataInputStreamTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;io-app2/src/itheima10out.txt&quot;</span>));</span><br><span class="line">                )&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">            System.out.println(i);</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> dis.readDouble();</span><br><span class="line">            System.out.println(d);</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line">            System.out.println(b);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">            System.out.println(rs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六序列化流">六、序列化流</h2>
<p>各位同学同学，还有最后一个流要学习，叫做序列化流。序列化流是干什么用的呢？
我们知道字节流是以字节为单位来读写数据、字符流是按照字符为单位来读写数据、而对象流是以对象为单位来读写数据。也就是把对象当做一个整体，可以写一个对象到文件，也可以从文件中把对象读取出来。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667924794181.png"></p>
<p>这里有一个新词
序列化，第一次听同学们可能还比较陌生，我来给同学们解释一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">序列化：意思就是把对象写到文件或者网络中去。（简单记：写对象）</span><br><span class="line">反序列化：意思就是把对象从文件或者网络中读取出来。（简单记：读对象）</span><br></pre></td></tr></table></figure>
<h3 id="objectoutputstraem类">6.1 ObjectOutputStraem类</h3>
<p>接下来，先学习ObjectOutputStream流，它也是一个包装流，不能单独使用，需要结合原始的字节输出流使用。</p>
<p>代码如下：将一个User对象写到文件中去</p>
<ul>
<li>第一步：先准备一个User类，必须让其实现Serializable接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：对象如果需要序列化，必须实现序列化接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String loginName;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// transient 这个成员变量将不参与序列化。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String passWord;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String loginName, String userName, <span class="type">int</span> age, String passWord)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loginName = loginName;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;loginName=&#x27;&quot;</span> + loginName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, userName=&#x27;&quot;</span> + userName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, passWord=&#x27;&quot;</span> + passWord + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步：再创建ObjectOutputStream流对象，调用writeObject方法对象到文件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1ObjectOutputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 2、创建一个对象字节输出流包装原始的字节 输出流。</span></span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;io-app2/src/itheima11out.txt&quot;</span>));</span><br><span class="line">                )&#123;</span><br><span class="line">            <span class="comment">// 1、创建一个Java对象。</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">32</span>, <span class="string">&quot;666888xyz&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、序列化对象到文件中去</span></span><br><span class="line">            oos.writeObject(u);</span><br><span class="line">            System.out.println(<span class="string">&quot;序列化对象成功！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：写到文件中的对象，是不能用记事本打开看的。因为对象本身就不是文本数据，打开是乱码</strong></p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667925212261.png"></p>
<p>怎样才能读懂文件中的对象是什么呢？这里必须用反序列化，自己写代码读。</p>
<h3 id="objectinputstream类">6.2 ObjectInputStream类</h3>
<p>接下来，学习ObjectInputStream流，它也是一个包装流，不能单独使用，需要结合原始的字节输入流使用。</p>
<p>接着前面的案例，文件中已经有一个Student对象，现在要使用ObjectInputStream读取出来。称之为反序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2ObjectInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">// 1、创建一个对象字节输入流管道，包装 低级的字节输入流与源文件接通</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;io-app2/src/itheima11out.txt&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User) ois.readObject();</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七补充知识io框架">七、补充知识：IO框架</h2>
<p>最后，再给同学们补充讲解一个知识，叫做IO框架。它有什么用呢？有同学经常问老师，我们只学习了IO流对文件复制，能不能复制文件夹呀？</p>
<p>当然是可以咯，但是如果让我们自己写复制文件夹的代码需要用到递归，还是比较麻烦的。为了简化对IO操作，<strong>由apache开源基金组织提供了一组有关IO流小框架，可以提高IO流的开发效率。</strong></p>
<p>这个框架的名字叫commons-io：其本质是别人写好的一些字节码文件（class文件），打包成了一个jar包。我们只需要把jar包引入到我们的项目中，就可以直接用了。</p>
<p>这里给同学们介绍一个jar包中提供的工具类叫FileUtils，它的部分功能如下，很方便，你一看名字就知道怎么用了。</p>
<p><img src="/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/1667925627850.png"></p>
<p>在写代码之前，先需要引入jar包，具体步骤如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在模块的目录下，新建一个lib文件夹</span><br><span class="line"><span class="number">2.</span>把jar包复制粘贴到lib文件夹下</span><br><span class="line"><span class="number">3.</span>选择lib下的jar包，右键点击Add As Library，然后就可以用了。</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonsIOTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.复制文件</span></span><br><span class="line">        FileUtils.copyFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;io-app2\\src\\itheima01.txt&quot;</span>), <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;io-app2/src/a.txt&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.复制文件夹</span></span><br><span class="line">        FileUtils.copyDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resource\\私人珍藏&quot;</span>), <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resource\\私人珍藏3&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.删除文件夹</span></span><br><span class="line">        FileUtils.deleteDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\resource\\私人珍藏3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java提供的原生的一行代码搞定很多事情</span></span><br><span class="line">         Files.copy(Path.of(<span class="string">&quot;io-app2\\src\\itheima01.txt&quot;</span>), Path.of(<span class="string">&quot;io-app2\\src\\b.txt&quot;</span>));</span><br><span class="line">        System.out.println(Files.readString(Path.of(<span class="string">&quot;io-app2\\src\\itheima01.txt&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">早起星人</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/">http://example.com/2023/09/15/JavaSE/day08-Stream%E6%B5%81%E3%80%81File%E7%B1%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a></div><div class="post_share"><div class="social-share" data-image="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.png" target="_blank"><img class="post-qr-code-img" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.png" target="_blank"><img class="post-qr-code-img" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/15/JavaSE/day11-%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="特殊文件、日志技术、多线程"><img class="cover" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png" onerror="onerror=null;src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">特殊文件、日志技术、多线程</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/15/JavaSE/day13-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E5%8F%8D%E5%B0%84/" title="网络编程、单元测试、反射"><img class="cover" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png" onerror="onerror=null;src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">网络编程、单元测试、反射</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/09/15/JavaSE/day04-%E5%B8%B8%E7%94%A8API/" title="常用API"><img class="cover" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-15</div><div class="title">常用API</div></div></a></div><div><a href="/2023/09/15/JavaSE/day05-Lambda%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E3%80%81%E7%AE%97%E6%B3%95%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="算法和数据结构（Lambda、方法引用、正则表达式）"><img class="cover" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-15</div><div class="title">算法和数据结构（Lambda、方法引用、正则表达式）</div></div></a></div><div><a href="/2023/09/15/JavaSE/day01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/" title="面向对象高级"><img class="cover" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-15</div><div class="title">面向对象高级</div></div></a></div><div><a href="/2023/09/15/JavaSE/day06-%E5%BC%82%E5%B8%B8%E3%80%81%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6%EF%BC%88Collection%E3%80%81List%E9%9B%86%E5%90%88%EF%BC%89/" title="集合进阶"><img class="cover" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-15</div><div class="title">集合进阶</div></div></a></div><div><a href="/2023/09/15/JavaSE/day11-%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="特殊文件、日志技术、多线程"><img class="cover" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-15</div><div class="title">特殊文件、日志技术、多线程</div></div></a></div><div><a href="/2023/08/06/JavaSE/%E5%8F%8D%E5%B0%84%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E4%BB%A3%E7%90%86/" title="反射、注解、代理、异常"><img class="cover" src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-06</div><div class="title">反射、注解、代理、异常</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230511141236.png" onerror="this.onerror=null;this.src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">早起星人</div><div class="author-info__description">true</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/oneDuter"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my study Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#day08-stream%E6%B5%81file%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">day08-Stream流、File类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80jdk8%E6%96%B0%E7%89%B9%E6%80%A7stream%E6%B5%81"><span class="toc-number">1.1.</span> <span class="toc-text">一、JDK8新特性（Stream流）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stream%E6%B5%81%E4%BD%93%E9%AA%8C"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 Stream流体验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stream%E6%B5%81%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 Stream流的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stream%E6%B5%81%E4%B8%AD%E9%97%B4%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 Stream流中间方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stream%E6%B5%81%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 Stream流终结方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8Cfile%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">二、File类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#file%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 File对象的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#file%E5%88%A4%E6%96%AD%E5%92%8C%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 File判断和获取方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 创建和删除方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%A4%B9%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 遍历文件夹方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E9%80%92%E5%BD%92"><span class="toc-number">1.3.</span> <span class="toc-text">三、递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%BC%95%E5%85%A5"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 递归算法引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 递归算法的执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 递归文件搜索</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day09-%E5%AD%97%E7%AC%A6%E9%9B%86io%E6%B5%81%E4%B8%80"><span class="toc-number">2.</span> <span class="toc-text">day09-字符集、IO流（一）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">2.1.</span> <span class="toc-text">一、字符集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9A%84%E6%9D%A5%E5%8E%86"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 字符集的来历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%89%E5%AD%97%E5%92%8C%E5%AD%97%E6%AF%8D%E7%9A%84%E7%BC%96%E7%A0%81%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 汉字和字母的编码特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unicode%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 Unicode字符集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%B0%8F%E7%BB%93"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.4 字符集小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81"><span class="toc-number">2.1.5.</span> <span class="toc-text">1.5 编码和解码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8Cio%E6%B5%81%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">2.2.</span> <span class="toc-text">二、IO流（字节流）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 IO流概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fileinputstream%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2
FileInputStream读取一个字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fileinputstream%E8%AF%BB%E5%8F%96%E5%A4%9A%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3
FileInputStream读取多个字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fileinputstream%E8%AF%BB%E5%8F%96%E5%85%A8%E9%83%A8%E5%AD%97%E8%8A%82"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4
FileInputStream读取全部字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fileoutputstream%E5%86%99%E5%AD%97%E8%8A%82"><span class="toc-number">2.2.5.</span> <span class="toc-text">2.5 FileOutputStream写字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.6.</span> <span class="toc-text">2.6 字节流复制文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89io%E6%B5%81%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE"><span class="toc-number">2.3.</span> <span class="toc-text">三、IO流资源释放</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk7%E4%BB%A5%E5%89%8D%E7%9A%84%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 JDK7以前的资源释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk7%E4%BB%A5%E5%90%8E%E7%9A%84%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 JDK7以后的资源释放</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day10-io%E6%B5%81%E4%BA%8C"><span class="toc-number">3.</span> <span class="toc-text">day10-IO流（二）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">3.1.</span> <span class="toc-text">一、字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#filereader%E7%B1%BB"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1 FileReader类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filewriter%E7%B1%BB"><span class="toc-number">3.1.2.</span> <span class="toc-text">1.2 FileWriter类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filewriter%E5%86%99%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.1.3.</span> <span class="toc-text">1.3 FileWriter写的注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">3.2.</span> <span class="toc-text">二、缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 缓冲字节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 字符缓冲流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3 缓冲流性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">3.3.</span> <span class="toc-text">三、转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inputstreamreader%E7%B1%BB"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1 InputStreamReader类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#outputstreamwriter%E7%B1%BB"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2 OutputStreamWriter类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">3.4.</span> <span class="toc-text">四、打印流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">3.4.1.</span> <span class="toc-text">4.1 打印流基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.4.2.</span> <span class="toc-text">4.2 重定向输出语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">3.5.</span> <span class="toc-text">五、数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dataoutputstream%E7%B1%BB"><span class="toc-number">3.5.1.</span> <span class="toc-text">5.1 DataOutputStream类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#datainputstream%E7%B1%BB"><span class="toc-number">3.5.2.</span> <span class="toc-text">5.2 DataInputStream类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81"><span class="toc-number">3.6.</span> <span class="toc-text">六、序列化流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#objectoutputstraem%E7%B1%BB"><span class="toc-number">3.6.1.</span> <span class="toc-text">6.1 ObjectOutputStraem类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#objectinputstream%E7%B1%BB"><span class="toc-number">3.6.2.</span> <span class="toc-text">6.2 ObjectInputStream类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86io%E6%A1%86%E6%9E%B6"><span class="toc-number">3.7.</span> <span class="toc-text">七、补充知识：IO框架</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/19/JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/" title="day02—数据类型、运算符"><img src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png" onerror="this.onerror=null;this.src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/404.jpg'" alt="day02—数据类型、运算符"/></a><div class="content"><a class="title" href="/2023/11/19/JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87/day02-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/" title="day02—数据类型、运算符">day02—数据类型、运算符</a><time datetime="2023-11-18T16:00:00.000Z" title="Created 2023-11-19 00:00:00">2023-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/19/JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" title="day03——程序流程控制"><img src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png" onerror="this.onerror=null;this.src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/404.jpg'" alt="day03——程序流程控制"/></a><div class="content"><a class="title" href="/2023/11/19/JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87/day03-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" title="day03——程序流程控制">day03——程序流程控制</a><time datetime="2023-11-18T16:00:00.000Z" title="Created 2023-11-19 00:00:00">2023-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/19/JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87/day05-%E6%96%B9%E6%B3%95/" title="day05——方法"><img src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png" onerror="this.onerror=null;this.src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/404.jpg'" alt="day05——方法"/></a><div class="content"><a class="title" href="/2023/11/19/JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87/day05-%E6%96%B9%E6%B3%95/" title="day05——方法">day05——方法</a><time datetime="2023-11-18T16:00:00.000Z" title="Created 2023-11-19 00:00:00">2023-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/19/JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87/day04-Java%E6%95%B0%E7%BB%84/" title="day04——Java数组"><img src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png" onerror="this.onerror=null;this.src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/404.jpg'" alt="day04——Java数组"/></a><div class="content"><a class="title" href="/2023/11/19/JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87/day04-Java%E6%95%B0%E7%BB%84/" title="day04——Java数组">day04——Java数组</a><time datetime="2023-11-18T16:00:00.000Z" title="Created 2023-11-19 00:00:00">2023-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/19/JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87/day06-Java%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B%EF%BC%88%E4%B8%93%E9%A2%98%EF%BC%89/" title="day06——Java编程案例（专题）"><img src="https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/cover/java-cover.png" onerror="this.onerror=null;this.src='https://lgj-duter.oss-cn-beijing.aliyuncs.com/img/404.jpg'" alt="day06——Java编程案例（专题）"/></a><div class="content"><a class="title" href="/2023/11/19/JavaSE/%E5%9F%BA%E7%A1%80%E7%AF%87/day06-Java%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B%EF%BC%88%E4%B8%93%E9%A2%98%EF%BC%89/" title="day06——Java编程案例（专题）">day06——Java编程案例（专题）</a><time datetime="2023-11-18T16:00:00.000Z" title="Created 2023-11-19 00:00:00">2023-11-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 早起星人</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>